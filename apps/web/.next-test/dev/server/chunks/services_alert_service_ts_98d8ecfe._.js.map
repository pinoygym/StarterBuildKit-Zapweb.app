{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///D:/Users/HI/Documents/GitHub/testTemplateGithub/services/alert.service.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma';\r\nimport { CreateAlertInput, AlertFilters, AlertType } from '@/types/alert.types';\r\nimport { randomUUID } from 'crypto';\r\n\r\nexport class AlertService {\r\n  /**\r\n   * Create a new alert\r\n   */\r\n  async createAlert(data: CreateAlertInput) {\r\n    return await prisma.notification.create({\r\n      data: {\r\n        id: randomUUID(),\r\n        type: data.type,\r\n        title: data.title,\r\n        message: data.message,\r\n        link: data.link,\r\n        userId: data.userId || null,\r\n        isRead: false,\r\n        createdAt: new Date(),\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get alerts for a user (or global)\r\n   */\r\n  async getAlerts(userId: string, filters?: AlertFilters) {\r\n    const where: any = {\r\n      // Logic: show alerts assigned to user OR global alerts (userId is null)\r\n      // BUT for simplicity, we might just filter by userId if provided.\r\n      // Let's assume userId is required for fetching *their* alerts.\r\n      OR: [\r\n        { userId: userId },\r\n        { userId: null }\r\n      ]\r\n    };\r\n\r\n    if (filters?.isRead !== undefined) {\r\n      where.isRead = filters.isRead;\r\n    }\r\n\r\n    if (filters?.type) {\r\n      where.type = filters.type;\r\n    }\r\n\r\n    return await prisma.notification.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n      take: filters?.limit || 50,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Mark alert as read\r\n   */\r\n  async markAsRead(id: string) {\r\n    return await prisma.notification.update({\r\n      where: { id },\r\n      data: { isRead: true },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Mark all alerts as read for a user\r\n   */\r\n  async markAllAsRead(userId: string) {\r\n    return await prisma.notification.updateMany({\r\n      where: { userId },\r\n      data: { isRead: true },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check for low stock items and generate alerts.\r\n   * This is idempotent-ish: It tries not to spam. \r\n   * A real production system might use a separate 'AlertState' table to track if we already alerted for Product X today.\r\n   * distinct: Use a simple check for now.\r\n   */\r\n  async checkLowStock(branchId?: string) {\r\n    // 1. Find products with stock < minStockLevel\r\n    // Note: Inventory is per warehouse. We need to aggregate or check per warehouse.\r\n    // Let's check per inventory record for granular warehouse alerts.\r\n\r\n    const lowStockItems = await prisma.inventory.findMany({\r\n      where: {\r\n        AND: [\r\n          {\r\n            Product: {\r\n              status: 'active',\r\n              minStockLevel: { gt: 0 }, // Only check if minStockLevel is set\r\n            },\r\n          },\r\n          {\r\n            Warehouse: branchId ? { branchId } : undefined,\r\n          }\r\n        ]\r\n      },\r\n      include: {\r\n        Product: true,\r\n        Warehouse: true,\r\n      },\r\n    });\r\n\r\n    const alertsCreated = [];\r\n\r\n    for (const item of lowStockItems) {\r\n      if (item.quantity <= item.Product.minStockLevel) {\r\n        // Double check: if quantity is 0, is it intentional? Yes, alert.\r\n\r\n        // Prevent duplicates: Check if an unread alert for this product already exists\r\n        const existingAlert = await prisma.notification.findFirst({\r\n          where: {\r\n            type: 'LOW_STOCK',\r\n            isRead: false,\r\n            message: { contains: item.Product.name } // Simple check, could be more robust with metadata if we added it\r\n          }\r\n        });\r\n\r\n        if (existingAlert) continue;\r\n\r\n        const alertData: CreateAlertInput = {\r\n          type: 'LOW_STOCK',\r\n          title: 'Low Stock Warning',\r\n          message: `Product ${item.Product.name} is low on stock (${item.quantity} ${item.Product.baseUOM}) in ${item.Warehouse.name}.`,\r\n          link: `/inventory/products/${item.Product.id}`,\r\n          // userId: null // System wide alert\r\n        };\r\n\r\n        // Fire and forget (or await if critical)\r\n        await this.createAlert(alertData);\r\n        alertsCreated.push(alertData);\r\n      }\r\n    }\r\n\r\n    return alertsCreated;\r\n  }\r\n\r\n  /**\r\n   * Get active alerts by checking current states (low stock, etc.)\r\n   * This is used by the Alerts page to show real-time status.\r\n   */\r\n  async getActiveAlerts(branchId?: string) {\r\n    const lowStockItems = await prisma.inventory.findMany({\r\n      where: {\r\n        AND: [\r\n          {\r\n            Product: {\r\n              status: 'active',\r\n              minStockLevel: { gt: 0 },\r\n            },\r\n          },\r\n          {\r\n            Warehouse: branchId ? { branchId } : undefined,\r\n          }\r\n        ]\r\n      },\r\n      include: {\r\n        Product: true,\r\n        Warehouse: true,\r\n      },\r\n    });\r\n\r\n    return lowStockItems\r\n      .filter(item => item.quantity <= item.Product.minStockLevel)\r\n      .map(item => ({\r\n        id: `low-stock-${item.productId}-${item.warehouseId}`,\r\n        type: 'low_stock',\r\n        severity: item.quantity === 0 || item.quantity < item.Product.minStockLevel * 0.5 ? 'critical' : 'warning',\r\n        productName: item.Product.name,\r\n        warehouseName: item.Warehouse.name,\r\n        details: `Stock: ${item.quantity} ${item.Product.baseUOM} / Min: ${item.Product.minStockLevel}`,\r\n        productId: item.productId,\r\n        warehouseId: item.warehouseId,\r\n        createdAt: item.updatedAt.toISOString(),\r\n      }));\r\n  }\r\n\r\n  /**\r\n   * Check for expiring batches (if tracking expiration)\r\n   * Prisma schema doesn't seem to have explicit 'Batch' model in the visible part, \r\n   * but Reference logic suggests FIFO/Average. \r\n   * Use ReceivingVoucher or StockMovements?\r\n   * \r\n   * Actually, `Product` has `shelfLifeDays`.\r\n   * Without a 'Batch' model with `expiryDate`, we can't do exact expiry tracking.\r\n   * \r\n   * WAIT: `InventoryAdjustmentItem` logic doesn't show batches.\r\n   * `ReceivingVoucher` has `receivedDate`.\r\n   * \r\n   * If the system uses FIFO, we can estimate expiry based on `ReceivingVoucher` date + `shelfLifeDays`.\r\n   * This is an estimation.\r\n   */\r\n  async checkExpirations() {\r\n    // This is complex without a dedicated Batch table.\r\n    // Skipping implementation until Batch model is confirmed or requested.\r\n    // For now, return empty.\r\n    return [];\r\n  }\r\n}\r\n\r\nexport const alertService = new AlertService();\r\n"],"names":[],"mappings":"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"}}]
}