{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/logger.ts"],"sourcesContent":["/**\r\n * Centralized Logging System\r\n */\r\n\r\nexport enum LogLevel {\r\n  ERROR = 'error',\r\n  WARN = 'warn',\r\n  INFO = 'info',\r\n  DEBUG = 'debug',\r\n}\r\n\r\ninterface LogEntry {\r\n  level: LogLevel;\r\n  message: string;\r\n  timestamp: string;\r\n  context?: any;\r\n  error?: Error;\r\n}\r\n\r\nclass Logger {\r\n  private isDevelopment = process.env.NODE_ENV === 'development';\r\n\r\n  private formatLog(entry: LogEntry): string {\r\n    const { level, message, timestamp, context } = entry;\r\n    let log = `[${timestamp}] [${level.toUpperCase()}] ${message}`;\r\n    \r\n    if (context) {\r\n      log += `\\nContext: ${JSON.stringify(context, null, 2)}`;\r\n    }\r\n    \r\n    if (entry.error) {\r\n      log += `\\nError: ${entry.error.message}\\nStack: ${entry.error.stack}`;\r\n    }\r\n    \r\n    return log;\r\n  }\r\n\r\n  private log(level: LogLevel, message: string, context?: any, error?: Error) {\r\n    const entry: LogEntry = {\r\n      level,\r\n      message,\r\n      timestamp: new Date().toISOString(),\r\n      context,\r\n      error,\r\n    };\r\n\r\n    const formattedLog = this.formatLog(entry);\r\n\r\n    // Console output based on environment\r\n    if (this.isDevelopment) {\r\n      switch (level) {\r\n        case LogLevel.ERROR:\r\n          console.error(formattedLog);\r\n          break;\r\n        case LogLevel.WARN:\r\n          console.warn(formattedLog);\r\n          break;\r\n        case LogLevel.INFO:\r\n          console.info(formattedLog);\r\n          break;\r\n        case LogLevel.DEBUG:\r\n          console.debug(formattedLog);\r\n          break;\r\n      }\r\n    } else {\r\n      // In production, you would send to external logging service\r\n      // e.g., Sentry, DataDog, CloudWatch, etc.\r\n      console.log(JSON.stringify(entry));\r\n    }\r\n  }\r\n\r\n  error(message: string, error?: Error, context?: any) {\r\n    this.log(LogLevel.ERROR, message, context, error);\r\n  }\r\n\r\n  warn(message: string, context?: any) {\r\n    this.log(LogLevel.WARN, message, context);\r\n  }\r\n\r\n  info(message: string, context?: any) {\r\n    this.log(LogLevel.INFO, message, context);\r\n  }\r\n\r\n  debug(message: string, context?: any) {\r\n    if (this.isDevelopment) {\r\n      this.log(LogLevel.DEBUG, message, context);\r\n    }\r\n  }\r\n}\r\n\r\nexport const logger = new Logger();\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;AAEM,IAAA,AAAK,kCAAA;;;;;WAAA;;AAeZ,MAAM;IACI,gBAAgB,oDAAyB,cAAc;IAEvD,UAAU,KAAe,EAAU;QACzC,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG;QAC/C,IAAI,MAAM,CAAC,CAAC,EAAE,UAAU,GAAG,EAAE,MAAM,WAAW,GAAG,EAAE,EAAE,SAAS;QAE9D,IAAI,SAAS;YACX,OAAO,CAAC,WAAW,EAAE,KAAK,SAAS,CAAC,SAAS,MAAM,IAAI;QACzD;QAEA,IAAI,MAAM,KAAK,EAAE;YACf,OAAO,CAAC,SAAS,EAAE,MAAM,KAAK,CAAC,OAAO,CAAC,SAAS,EAAE,MAAM,KAAK,CAAC,KAAK,EAAE;QACvE;QAEA,OAAO;IACT;IAEQ,IAAI,KAAe,EAAE,OAAe,EAAE,OAAa,EAAE,KAAa,EAAE;QAC1E,MAAM,QAAkB;YACtB;YACA;YACA,WAAW,IAAI,OAAO,WAAW;YACjC;YACA;QACF;QAEA,MAAM,eAAe,IAAI,CAAC,SAAS,CAAC;QAEpC,sCAAsC;QACtC,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,OAAQ;gBACN;oBACE,QAAQ,KAAK,CAAC;oBACd;gBACF;oBACE,QAAQ,IAAI,CAAC;oBACb;gBACF;oBACE,QAAQ,IAAI,CAAC;oBACb;gBACF;oBACE,QAAQ,KAAK,CAAC;oBACd;YACJ;QACF,OAAO;YACL,4DAA4D;YAC5D,0CAA0C;YAC1C,QAAQ,GAAG,CAAC,KAAK,SAAS,CAAC;QAC7B;IACF;IAEA,MAAM,OAAe,EAAE,KAAa,EAAE,OAAa,EAAE;QACnD,IAAI,CAAC,GAAG,UAAiB,SAAS,SAAS;IAC7C;IAEA,KAAK,OAAe,EAAE,OAAa,EAAE;QACnC,IAAI,CAAC,GAAG,SAAgB,SAAS;IACnC;IAEA,KAAK,OAAe,EAAE,OAAa,EAAE;QACnC,IAAI,CAAC,GAAG,SAAgB,SAAS;IACnC;IAEA,MAAM,OAAe,EAAE,OAAa,EAAE;QACpC,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,IAAI,CAAC,GAAG,UAAiB,SAAS;QACpC;IACF;AACF;AAEO,MAAM,SAAS,IAAI"}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/prisma.ts"],"sourcesContent":["import dotenv from 'dotenv';\r\nconst envState = `[${new Date().toISOString()}] NODE_ENV: ${process.env.NODE_ENV}, IS_PLAYWRIGHT: ${process.env.IS_PLAYWRIGHT}`;\r\ntry {\r\n  const fs = require('fs');\r\n  fs.appendFileSync('prisma_debug.log', `${envState}\\n`);\r\n} catch (e) { }\r\n\r\nif (process.env.NODE_ENV === 'test' || process.env.IS_PLAYWRIGHT === 'true') {\r\n  dotenv.config({ path: '.env.test', override: true });\r\n} else {\r\n  dotenv.config({ path: '.env.local' });\r\n}\r\n\r\nconst dbUrlLog = `[${new Date().toISOString()}] DB URL HOST: ${process.env.DATABASE_URL?.split('@')[1]?.split('/')[0] || 'unknown'}`;\r\ntry {\r\n  const fs = require('fs');\r\n  fs.appendFileSync('prisma_debug.log', `${dbUrlLog}\\n\\n`);\r\n} catch (e) { }\r\n\r\nimport { PrismaClient, Prisma } from '@prisma/client';\r\nimport { PrismaPg } from '@prisma/adapter-pg';\r\nimport { Pool } from 'pg';\r\nimport { logger } from './logger';\r\n\r\nexport { Prisma };\r\n\r\n// Prevent multiple instances of Prisma Client in development\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined;\r\n  pool: Pool | undefined;\r\n};\r\n\r\nconst connectionString = process.env.DATABASE_URL?.includes('localhost')\r\n  ? process.env.DATABASE_URL.replace('localhost', '127.0.0.1')\r\n  : process.env.DATABASE_URL;\r\n\r\nif (!connectionString) {\r\n  logger.error('DATABASE_URL is not defined in lib/prisma.ts');\r\n} else {\r\n  const host = connectionString.split('@')[1]?.split('/')[0];\r\n  const dbName = connectionString.split('/').pop()?.split('?')[0];\r\n  logger.info(`Initializing Prisma with Host: ${host}, DB: ${dbName}`);\r\n  console.log(`[DEBUG] Prisma Source: ${process.env.NODE_ENV === 'test' ? '.env.test' : '.env.local'} | Host: ${host}`);\r\n}\r\n\r\n// Create PostgreSQL connection pool\r\nconst pool = globalForPrisma.pool ?? new Pool({ connectionString });\r\nconst adapter = new PrismaPg(pool);\r\n\r\n// Optimized Prisma Client configuration\r\nconst prismaConfig: any = {\r\n  adapter,\r\n  log: [\r\n    {\r\n      emit: 'event',\r\n      level: 'query',\r\n    },\r\n    {\r\n      emit: 'event',\r\n      level: 'error',\r\n    },\r\n    {\r\n      emit: 'event',\r\n      level: 'warn',\r\n    },\r\n  ],\r\n};\r\n\r\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient(prismaConfig);\r\n\r\n// Log slow queries in development\r\nif (process.env.NODE_ENV === 'development') {\r\n  prisma.$on('query' as never, (e: any) => {\r\n    if (e.duration > 1000) {\r\n      // Log queries taking more than 1 second\r\n      logger.warn('Slow query detected', {\r\n        query: e.query,\r\n        duration: `${e.duration}ms`,\r\n        params: e.params,\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n// Log errors\r\nprisma.$on('error' as never, (e: any) => {\r\n  logger.error('Prisma error', e instanceof Error ? e : undefined, {\r\n    target: e.target,\r\n    timestamp: e.timestamp,\r\n    message: e.message,\r\n  });\r\n});\r\n\r\n// Log warnings\r\nprisma.$on('warn' as never, (e: any) => {\r\n  logger.warn('Prisma warning', {\r\n    message: e.message,\r\n    timestamp: e.timestamp,\r\n  });\r\n});\r\n\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  globalForPrisma.prisma = prisma;\r\n  if (pool) {\r\n    globalForPrisma.pool = pool;\r\n  }\r\n}\r\n\r\n// Graceful shutdown\r\nprocess.on('beforeExit', async () => {\r\n  await prisma.$disconnect();\r\n  if (pool) {\r\n    await pool.end();\r\n  }\r\n});\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/repositories/branch.repository.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma';\r\nimport { Branch } from '@prisma/client';\r\nimport { Prisma } from '@prisma/client';\r\nimport { randomUUID } from 'crypto';\r\nimport { CreateBranchInput, UpdateBranchInput } from '@/types/branch.types';\r\n\r\nexport class BranchRepository {\r\n  async findAll(): Promise<Branch[]> {\r\n    return await prisma.branch.findMany({\r\n      orderBy: { name: 'asc' },\r\n    });\r\n  }\r\n\r\n  async findById(id: string): Promise<Branch | null> {\r\n    return await prisma.branch.findUnique({\r\n      where: { id },\r\n    });\r\n  }\r\n\r\n  async findByCode(code: string): Promise<Branch | null> {\r\n    return await prisma.branch.findUnique({\r\n      where: { code },\r\n    });\r\n  }\r\n\r\n  async create(data: CreateBranchInput): Promise<Branch> {\r\n    return await prisma.branch.create({\r\n      data: {\r\n        id: randomUUID(),\r\n        name: data.name,\r\n        code: data.code,\r\n        location: data.location,\r\n        manager: data.manager,\r\n        phone: data.phone,\r\n        status: data.status || 'active',\r\n        updatedAt: new Date(),\r\n      },\r\n    });\r\n  }\r\n\r\n  async update(id: string, data: UpdateBranchInput): Promise<Branch> {\r\n    return await prisma.branch.update({\r\n      where: { id },\r\n      data,\r\n    });\r\n  }\r\n\r\n  async delete(id: string): Promise<Branch> {\r\n    return await prisma.branch.delete({\r\n      where: { id },\r\n    });\r\n  }\r\n\r\n  async findActive(): Promise<Branch[]> {\r\n    return await prisma.branch.findMany({\r\n      where: { status: 'active' },\r\n      orderBy: { name: 'asc' },\r\n    });\r\n  }\r\n}\r\n\r\nexport const branchRepository = new BranchRepository();\r\n"],"names":[],"mappings":";;;;;;AAAA;AAGA;;;;;;;AAGO,MAAM;IACX,MAAM,UAA6B;QACjC,OAAO,MAAM,4KAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;YAClC,SAAS;gBAAE,MAAM;YAAM;QACzB;IACF;IAEA,MAAM,SAAS,EAAU,EAA0B;QACjD,OAAO,MAAM,4KAAM,CAAC,MAAM,CAAC,UAAU,CAAC;YACpC,OAAO;gBAAE;YAAG;QACd;IACF;IAEA,MAAM,WAAW,IAAY,EAA0B;QACrD,OAAO,MAAM,4KAAM,CAAC,MAAM,CAAC,UAAU,CAAC;YACpC,OAAO;gBAAE;YAAK;QAChB;IACF;IAEA,MAAM,OAAO,IAAuB,EAAmB;QACrD,OAAO,MAAM,4KAAM,CAAC,MAAM,CAAC,MAAM,CAAC;YAChC,MAAM;gBACJ,IAAI,IAAA,mHAAU;gBACd,MAAM,KAAK,IAAI;gBACf,MAAM,KAAK,IAAI;gBACf,UAAU,KAAK,QAAQ;gBACvB,SAAS,KAAK,OAAO;gBACrB,OAAO,KAAK,KAAK;gBACjB,QAAQ,KAAK,MAAM,IAAI;gBACvB,WAAW,IAAI;YACjB;QACF;IACF;IAEA,MAAM,OAAO,EAAU,EAAE,IAAuB,EAAmB;QACjE,OAAO,MAAM,4KAAM,CAAC,MAAM,CAAC,MAAM,CAAC;YAChC,OAAO;gBAAE;YAAG;YACZ;QACF;IACF;IAEA,MAAM,OAAO,EAAU,EAAmB;QACxC,OAAO,MAAM,4KAAM,CAAC,MAAM,CAAC,MAAM,CAAC;YAChC,OAAO;gBAAE;YAAG;QACd;IACF;IAEA,MAAM,aAAgC;QACpC,OAAO,MAAM,4KAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;YAClC,OAAO;gBAAE,QAAQ;YAAS;YAC1B,SAAS;gBAAE,MAAM;YAAM;QACzB;IACF;AACF;AAEO,MAAM,mBAAmB,IAAI"}},
    {"offset": {"line": 366, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/errors.ts"],"sourcesContent":["/**\r\n * Centralized Error Handling for InventoryPro\r\n * Consolidates all custom error classes and utilities\r\n */\r\n\r\nimport { Prisma } from '@prisma/client';\r\n\r\n/**\r\n * Error codes for consistent error identification\r\n */\r\nexport enum ErrorCode {\r\n  // Client Errors (4xx)\r\n  BAD_REQUEST = 'BAD_REQUEST',\r\n  UNAUTHORIZED = 'UNAUTHORIZED',\r\n  FORBIDDEN = 'FORBIDDEN',\r\n  NOT_FOUND = 'NOT_FOUND',\r\n  CONFLICT = 'CONFLICT',\r\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\r\n\r\n  // Server Errors (5xx)\r\n  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',\r\n  DATABASE_ERROR = 'DATABASE_ERROR',\r\n  EXTERNAL_SERVICE_ERROR = 'EXTERNAL_SERVICE_ERROR',\r\n\r\n  // Business Logic Errors\r\n  INSUFFICIENT_STOCK = 'INSUFFICIENT_STOCK',\r\n  DUPLICATE_ENTRY = 'DUPLICATE_ENTRY',\r\n  INVALID_OPERATION = 'INVALID_OPERATION',\r\n}\r\n\r\n/**\r\n * Base application error class\r\n * All custom errors should extend this class\r\n */\r\nexport class AppError extends Error {\r\n  public readonly statusCode: number;\r\n  public readonly code: ErrorCode;\r\n  public readonly isOperational: boolean;\r\n  public readonly details?: any;\r\n\r\n  constructor(\r\n    message: string,\r\n    statusCode: number = 500,\r\n    code: ErrorCode = ErrorCode.INTERNAL_SERVER_ERROR,\r\n    isOperational: boolean = true,\r\n    details?: any\r\n  ) {\r\n    super(message);\r\n    Object.setPrototypeOf(this, new.target.prototype);\r\n\r\n    this.statusCode = statusCode;\r\n    this.code = code;\r\n    this.isOperational = isOperational;\r\n    this.details = details;\r\n    this.name = this.constructor.name;\r\n\r\n    Error.captureStackTrace(this);\r\n  }\r\n}\r\n\r\n/**\r\n * Validation error - for invalid input data\r\n */\r\nexport class ValidationError extends AppError {\r\n  constructor(message: string, public fields?: Record<string, string | string[]>) {\r\n    super(message, 400, ErrorCode.VALIDATION_ERROR, true, fields);\r\n  }\r\n}\r\n\r\n/**\r\n * Not found error - for missing resources\r\n */\r\nexport class NotFoundError extends AppError {\r\n  constructor(resource: string, identifier?: string) {\r\n    const message = identifier\r\n      ? `${resource} with identifier '${identifier}' not found`\r\n      : `${resource} not found`;\r\n    super(message, 404, ErrorCode.NOT_FOUND, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Conflict error - for duplicate entries or conflicting operations\r\n */\r\nexport class ConflictError extends AppError {\r\n  constructor(message: string, details?: any) {\r\n    super(message, 409, ErrorCode.CONFLICT, true, details);\r\n  }\r\n}\r\n\r\n/**\r\n * Database error - for database operation failures\r\n */\r\nexport class DatabaseError extends AppError {\r\n  constructor(message: string, details?: any) {\r\n    super(message, 500, ErrorCode.DATABASE_ERROR, true, details);\r\n  }\r\n}\r\n\r\n/**\r\n * Insufficient stock error - for inventory stock issues\r\n */\r\nexport class InsufficientStockError extends AppError {\r\n  constructor(productName: string, available: number, requested: number) {\r\n    super(\r\n      `Insufficient stock for ${productName}. Available: ${available}, Requested: ${requested}`,\r\n      400,\r\n      ErrorCode.INSUFFICIENT_STOCK,\r\n      true,\r\n      { productName, available, requested }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Unauthorized error - for authentication failures\r\n */\r\nexport class UnauthorizedError extends AppError {\r\n  constructor(message: string = 'Unauthorized access') {\r\n    super(message, 401, ErrorCode.UNAUTHORIZED, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Forbidden error - for authorization failures\r\n */\r\nexport class ForbiddenError extends AppError {\r\n  constructor(message: string = 'Access forbidden') {\r\n    super(message, 403, ErrorCode.FORBIDDEN, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Prisma Error Handler\r\n * Transforms Prisma errors into user-friendly AppErrors\r\n */\r\nexport function handlePrismaError(error: unknown, context?: string): AppError {\r\n  // Log the original error for debugging\r\n  console.error('===== PRISMA ERROR =====');\r\n  console.error('Context:', context);\r\n  console.error('Error:', error);\r\n  if (error instanceof Error) {\r\n    console.error('Message:', error.message);\r\n    console.error('Stack:', error.stack);\r\n  }\r\n  if (error instanceof Prisma.PrismaClientKnownRequestError) {\r\n    console.error('Prisma Code:', error.code);\r\n    console.error('Prisma Meta:', error.meta);\r\n  }\r\n  console.error('========================');\r\n\r\n  // Prisma Client Known Request Error (e.g., unique constraint, foreign key)\r\n  if (error instanceof Prisma.PrismaClientKnownRequestError) {\r\n    switch (error.code) {\r\n      case 'P2002': {\r\n        // Unique constraint violation\r\n        const target = (error.meta?.target as string[]) || [];\r\n        const field = target[0] || 'field';\r\n        return new ConflictError(\r\n          `A record with this ${field} already exists`,\r\n          { field, code: error.code }\r\n        );\r\n      }\r\n      case 'P2003': {\r\n        // Foreign key constraint violation\r\n        const field = error.meta?.field_name as string;\r\n\r\n        // If operation is delete, it means record is in use\r\n        if (context && (context.toLowerCase().includes('delete') || context.toLowerCase().includes('remove'))) {\r\n          return new ConflictError(\r\n            `Cannot delete record because it is referenced by other data (Constraint: ${field || 'unknown'})`,\r\n            { field, code: error.code }\r\n          );\r\n        }\r\n\r\n        return new ValidationError(\r\n          `Invalid reference: ${field || 'related record'} does not exist`,\r\n          { [field || 'reference']: 'Referenced record not found' }\r\n        );\r\n      }\r\n      case 'P2025': {\r\n        // Record not found\r\n        return new NotFoundError('Record');\r\n      }\r\n      case 'P2014': {\r\n        // Required relation violation\r\n        return new ValidationError(\r\n          'Required relationship is missing',\r\n          { relation: 'Required related record is missing' }\r\n        );\r\n      }\r\n      default: {\r\n        return new DatabaseError(\r\n          `Database operation failed: ${error.code} - ${error.message}`,\r\n          { code: error.code, meta: error.meta }\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Prisma Client Validation Error (e.g., invalid query)\r\n  if (error instanceof Prisma.PrismaClientValidationError) {\r\n    return new ValidationError(`Invalid data provided to database: ${error.message}`);\r\n  }\r\n\r\n  // Prisma Client Initialization Error\r\n  if (error instanceof Prisma.PrismaClientInitializationError) {\r\n    return new DatabaseError('Database connection failed', {\r\n      code: error.errorCode,\r\n    });\r\n  }\r\n\r\n  // Prisma Client Rust Panic Error\r\n  if (error instanceof Prisma.PrismaClientRustPanicError) {\r\n    return new DatabaseError('Database engine error', {\r\n      message: error.message,\r\n    });\r\n  }\r\n\r\n  // If it's already an AppError, return it\r\n  if (error instanceof AppError) {\r\n    return error;\r\n  }\r\n\r\n  // Unknown error\r\n  return new AppError(\r\n    error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    500,\r\n    ErrorCode.INTERNAL_SERVER_ERROR,\r\n    false\r\n  );\r\n}\r\n\r\n/**\r\n * Safe error handler for repositories\r\n * Wraps repository operations and transforms errors\r\n */\r\nexport async function withErrorHandling<T>(\r\n  operation: () => Promise<T>,\r\n  context?: string\r\n): Promise<T> {\r\n  try {\r\n    return await operation();\r\n  } catch (error) {\r\n    const appError = handlePrismaError(error, context);\r\n\r\n    // Add context if provided\r\n    if (context && appError.details) {\r\n      appError.details.context = context;\r\n    }\r\n\r\n    throw appError;\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 572, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/validations/branch.validation.ts"],"sourcesContent":["import { z } from 'zod';\r\n\r\nexport const branchSchema = z.object({\r\n  name: z.string().min(1, 'Branch name is required').max(100, 'Branch name is too long'),\r\n  code: z.string().min(1, 'Branch code is required').max(20, 'Branch code is too long'),\r\n  location: z.string().min(1, 'Location is required').max(200, 'Location is too long'),\r\n  manager: z.string().min(1, 'Manager name is required').max(100, 'Manager name is too long'),\r\n  phone: z.string().min(1, 'Phone number is required').regex(/^[0-9+\\-\\s()]+$/, 'Invalid phone number format'),\r\n  status: z.enum(['active', 'inactive']).optional().default('active'),\r\n});\r\n\r\nexport const updateBranchSchema = branchSchema.partial();\r\n\r\nexport type BranchFormData = z.infer<typeof branchSchema>;\r\nexport type UpdateBranchFormData = z.infer<typeof updateBranchSchema>;\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEO,MAAM,eAAe,4MAAC,CAAC,MAAM,CAAC;IACnC,MAAM,4MAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,2BAA2B,GAAG,CAAC,KAAK;IAC5D,MAAM,4MAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,2BAA2B,GAAG,CAAC,IAAI;IAC3D,UAAU,4MAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,wBAAwB,GAAG,CAAC,KAAK;IAC7D,SAAS,4MAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,4BAA4B,GAAG,CAAC,KAAK;IAChE,OAAO,4MAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,4BAA4B,KAAK,CAAC,mBAAmB;IAC9E,QAAQ,4MAAC,CAAC,IAAI,CAAC;QAAC;QAAU;KAAW,EAAE,QAAQ,GAAG,OAAO,CAAC;AAC5D;AAEO,MAAM,qBAAqB,aAAa,OAAO"}},
    {"offset": {"line": 598, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/services/branch.service.ts"],"sourcesContent":["import { Branch } from '@prisma/client';\r\nimport { branchRepository } from '@/repositories/branch.repository';\r\nimport { CreateBranchInput, UpdateBranchInput } from '@/types/branch.types';\r\nimport { ValidationError, NotFoundError } from '@/lib/errors';\r\nimport { branchSchema, updateBranchSchema } from '@/lib/validations/branch.validation';\r\n\r\nexport class BranchService {\r\n  async getAllBranches(): Promise<Branch[]> {\r\n    return await branchRepository.findAll();\r\n  }\r\n\r\n  async getBranchById(id: string): Promise<Branch> {\r\n    const branch = await branchRepository.findById(id);\r\n    if (!branch) {\r\n      throw new NotFoundError('Branch');\r\n    }\r\n    return branch;\r\n  }\r\n\r\n  async getActiveBranches(): Promise<Branch[]> {\r\n    return await branchRepository.findActive();\r\n  }\r\n\r\n  async createBranch(data: CreateBranchInput): Promise<Branch> {\r\n    // Validate input\r\n    const validationResult = branchSchema.safeParse(data);\r\n    if (!validationResult.success) {\r\n      const errors = validationResult.error.flatten().fieldErrors;\r\n      throw new ValidationError('Invalid branch data', errors as Record<string, string>);\r\n    }\r\n\r\n    // Check if branch code already exists\r\n    const existingBranch = await branchRepository.findByCode(data.code);\r\n    if (existingBranch) {\r\n      throw new ValidationError('Branch code already exists', { code: 'Branch code must be unique' });\r\n    }\r\n\r\n    return await branchRepository.create(validationResult.data);\r\n  }\r\n\r\n  async updateBranch(id: string, data: UpdateBranchInput): Promise<Branch> {\r\n    // Check if branch exists\r\n    const existingBranch = await branchRepository.findById(id);\r\n    if (!existingBranch) {\r\n      throw new NotFoundError('Branch');\r\n    }\r\n\r\n    // Validate input\r\n    const validationResult = updateBranchSchema.safeParse(data);\r\n    if (!validationResult.success) {\r\n      const errors = validationResult.error.flatten().fieldErrors;\r\n      throw new ValidationError('Invalid branch data', errors as Record<string, string>);\r\n    }\r\n\r\n    // Check if branch code is being updated and if it already exists\r\n    if (data.code && data.code !== existingBranch.code) {\r\n      const branchWithCode = await branchRepository.findByCode(data.code);\r\n      if (branchWithCode) {\r\n        throw new ValidationError('Branch code already exists', { code: 'Branch code must be unique' });\r\n      }\r\n    }\r\n\r\n    return await branchRepository.update(id, validationResult.data);\r\n  }\r\n\r\n  async deleteBranch(id: string): Promise<void> {\r\n    // Check if branch exists\r\n    const branch = await branchRepository.findById(id);\r\n    if (!branch) {\r\n      throw new NotFoundError('Branch');\r\n    }\r\n\r\n    // Note: In a production system, you might want to check for related records\r\n    // and prevent deletion if there are warehouses, orders, etc. linked to this branch\r\n    // For now, we'll allow deletion (Prisma will handle cascade rules)\r\n\r\n    await branchRepository.delete(id);\r\n  }\r\n\r\n  async toggleBranchStatus(id: string): Promise<Branch> {\r\n    const branch = await this.getBranchById(id);\r\n    const newStatus = branch.status === 'active' ? 'inactive' : 'active';\r\n    return await this.updateBranch(id, { status: newStatus });\r\n  }\r\n}\r\n\r\nexport const branchService = new BranchService();\r\n"],"names":[],"mappings":";;;;;;AACA;AAEA;AACA;;;;;;;;AAEO,MAAM;IACX,MAAM,iBAAoC;QACxC,OAAO,MAAM,6LAAgB,CAAC,OAAO;IACvC;IAEA,MAAM,cAAc,EAAU,EAAmB;QAC/C,MAAM,SAAS,MAAM,6LAAgB,CAAC,QAAQ,CAAC;QAC/C,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,mKAAa,CAAC;QAC1B;QACA,OAAO;IACT;IAEA,MAAM,oBAAuC;QAC3C,OAAO,MAAM,6LAAgB,CAAC,UAAU;IAC1C;IAEA,MAAM,aAAa,IAAuB,EAAmB;QAC3D,iBAAiB;QACjB,MAAM,mBAAmB,+LAAY,CAAC,SAAS,CAAC;QAChD,IAAI,CAAC,iBAAiB,OAAO,EAAE;YAC7B,MAAM,SAAS,iBAAiB,KAAK,CAAC,OAAO,GAAG,WAAW;YAC3D,MAAM,IAAI,qKAAe,CAAC,uBAAuB;QACnD;QAEA,sCAAsC;QACtC,MAAM,iBAAiB,MAAM,6LAAgB,CAAC,UAAU,CAAC,KAAK,IAAI;QAClE,IAAI,gBAAgB;YAClB,MAAM,IAAI,qKAAe,CAAC,8BAA8B;gBAAE,MAAM;YAA6B;QAC/F;QAEA,OAAO,MAAM,6LAAgB,CAAC,MAAM,CAAC,iBAAiB,IAAI;IAC5D;IAEA,MAAM,aAAa,EAAU,EAAE,IAAuB,EAAmB;QACvE,yBAAyB;QACzB,MAAM,iBAAiB,MAAM,6LAAgB,CAAC,QAAQ,CAAC;QACvD,IAAI,CAAC,gBAAgB;YACnB,MAAM,IAAI,mKAAa,CAAC;QAC1B;QAEA,iBAAiB;QACjB,MAAM,mBAAmB,qMAAkB,CAAC,SAAS,CAAC;QACtD,IAAI,CAAC,iBAAiB,OAAO,EAAE;YAC7B,MAAM,SAAS,iBAAiB,KAAK,CAAC,OAAO,GAAG,WAAW;YAC3D,MAAM,IAAI,qKAAe,CAAC,uBAAuB;QACnD;QAEA,iEAAiE;QACjE,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,KAAK,eAAe,IAAI,EAAE;YAClD,MAAM,iBAAiB,MAAM,6LAAgB,CAAC,UAAU,CAAC,KAAK,IAAI;YAClE,IAAI,gBAAgB;gBAClB,MAAM,IAAI,qKAAe,CAAC,8BAA8B;oBAAE,MAAM;gBAA6B;YAC/F;QACF;QAEA,OAAO,MAAM,6LAAgB,CAAC,MAAM,CAAC,IAAI,iBAAiB,IAAI;IAChE;IAEA,MAAM,aAAa,EAAU,EAAiB;QAC5C,yBAAyB;QACzB,MAAM,SAAS,MAAM,6LAAgB,CAAC,QAAQ,CAAC;QAC/C,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,mKAAa,CAAC;QAC1B;QAEA,4EAA4E;QAC5E,mFAAmF;QACnF,mEAAmE;QAEnE,MAAM,6LAAgB,CAAC,MAAM,CAAC;IAChC;IAEA,MAAM,mBAAmB,EAAU,EAAmB;QACpD,MAAM,SAAS,MAAM,IAAI,CAAC,aAAa,CAAC;QACxC,MAAM,YAAY,OAAO,MAAM,KAAK,WAAW,aAAa;QAC5D,OAAO,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI;YAAE,QAAQ;QAAU;IACzD;AACF;AAEO,MAAM,gBAAgB,IAAI"}},
    {"offset": {"line": 694, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/app/api/branches/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { branchService } from '@/services/branch.service';\r\nimport { AppError } from '@/lib/errors';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\n// GET /api/branches - Fetch all branches\r\nexport async function GET() {\r\n  try {\r\n    const branches = await branchService.getAllBranches();\r\n    return NextResponse.json({ success: true, data: branches });\r\n  } catch (error) {\r\n    console.error('Error fetching branches:', error);\r\n\r\n    if (error instanceof AppError) {\r\n      return NextResponse.json(\r\n        { success: false, error: error.message },\r\n        { status: error.statusCode }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to fetch branches' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// POST /api/branches - Create a new branch\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json();\r\n    console.log('Branch creation request body:', body);\r\n    const branch = await branchService.createBranch(body);\r\n\r\n    return NextResponse.json(\r\n      { success: true, data: branch },\r\n      { status: 201 }\r\n    );\r\n  } catch (error) {\r\n    console.error('Error creating branch:', error);\r\n    console.error('Error details:', error instanceof Error ? error.message : error);\r\n\r\n    if (error instanceof AppError) {\r\n      return NextResponse.json(\r\n        { success: false, error: error.message, fields: (error as any).fields },\r\n        { status: error.statusCode }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to create branch' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;;;;;AAEO,MAAM,UAAU;AAGhB,eAAe;IACpB,IAAI;QACF,MAAM,WAAW,MAAM,mLAAa,CAAC,cAAc;QACnD,OAAO,mLAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM,MAAM;QAAS;IAC3D,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAE1C,IAAI,iBAAiB,8JAAQ,EAAE;YAC7B,OAAO,mLAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO,MAAM,OAAO;YAAC,GACvC;gBAAE,QAAQ,MAAM,UAAU;YAAC;QAE/B;QAEA,OAAO,mLAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAA2B,GACpD;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,QAAQ,GAAG,CAAC,iCAAiC;QAC7C,MAAM,SAAS,MAAM,mLAAa,CAAC,YAAY,CAAC;QAEhD,OAAO,mLAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAM,MAAM;QAAO,GAC9B;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,QAAQ,KAAK,CAAC,kBAAkB,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAEzE,IAAI,iBAAiB,8JAAQ,EAAE;YAC7B,OAAO,mLAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO,MAAM,OAAO;gBAAE,QAAQ,AAAC,MAAc,MAAM;YAAC,GACtE;gBAAE,QAAQ,MAAM,UAAU;YAAC;QAE/B;QAEA,OAAO,mLAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAA0B,GACnD;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}