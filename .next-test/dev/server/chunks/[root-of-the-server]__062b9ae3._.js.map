{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/logger.ts"],"sourcesContent":["/**\r\n * Centralized Logging System\r\n */\r\n\r\nexport enum LogLevel {\r\n  ERROR = 'error',\r\n  WARN = 'warn',\r\n  INFO = 'info',\r\n  DEBUG = 'debug',\r\n}\r\n\r\ninterface LogEntry {\r\n  level: LogLevel;\r\n  message: string;\r\n  timestamp: string;\r\n  context?: any;\r\n  error?: Error;\r\n}\r\n\r\nclass Logger {\r\n  private isDevelopment = process.env.NODE_ENV === 'development';\r\n\r\n  private formatLog(entry: LogEntry): string {\r\n    const { level, message, timestamp, context } = entry;\r\n    let log = `[${timestamp}] [${level.toUpperCase()}] ${message}`;\r\n    \r\n    if (context) {\r\n      log += `\\nContext: ${JSON.stringify(context, null, 2)}`;\r\n    }\r\n    \r\n    if (entry.error) {\r\n      log += `\\nError: ${entry.error.message}\\nStack: ${entry.error.stack}`;\r\n    }\r\n    \r\n    return log;\r\n  }\r\n\r\n  private log(level: LogLevel, message: string, context?: any, error?: Error) {\r\n    const entry: LogEntry = {\r\n      level,\r\n      message,\r\n      timestamp: new Date().toISOString(),\r\n      context,\r\n      error,\r\n    };\r\n\r\n    const formattedLog = this.formatLog(entry);\r\n\r\n    // Console output based on environment\r\n    if (this.isDevelopment) {\r\n      switch (level) {\r\n        case LogLevel.ERROR:\r\n          console.error(formattedLog);\r\n          break;\r\n        case LogLevel.WARN:\r\n          console.warn(formattedLog);\r\n          break;\r\n        case LogLevel.INFO:\r\n          console.info(formattedLog);\r\n          break;\r\n        case LogLevel.DEBUG:\r\n          console.debug(formattedLog);\r\n          break;\r\n      }\r\n    } else {\r\n      // In production, you would send to external logging service\r\n      // e.g., Sentry, DataDog, CloudWatch, etc.\r\n      console.log(JSON.stringify(entry));\r\n    }\r\n  }\r\n\r\n  error(message: string, error?: Error, context?: any) {\r\n    this.log(LogLevel.ERROR, message, context, error);\r\n  }\r\n\r\n  warn(message: string, context?: any) {\r\n    this.log(LogLevel.WARN, message, context);\r\n  }\r\n\r\n  info(message: string, context?: any) {\r\n    this.log(LogLevel.INFO, message, context);\r\n  }\r\n\r\n  debug(message: string, context?: any) {\r\n    if (this.isDevelopment) {\r\n      this.log(LogLevel.DEBUG, message, context);\r\n    }\r\n  }\r\n}\r\n\r\nexport const logger = new Logger();\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;AAEM,IAAA,AAAK,kCAAA;;;;;WAAA;;AAeZ,MAAM;IACI,gBAAgB,oDAAyB,cAAc;IAEvD,UAAU,KAAe,EAAU;QACzC,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG;QAC/C,IAAI,MAAM,CAAC,CAAC,EAAE,UAAU,GAAG,EAAE,MAAM,WAAW,GAAG,EAAE,EAAE,SAAS;QAE9D,IAAI,SAAS;YACX,OAAO,CAAC,WAAW,EAAE,KAAK,SAAS,CAAC,SAAS,MAAM,IAAI;QACzD;QAEA,IAAI,MAAM,KAAK,EAAE;YACf,OAAO,CAAC,SAAS,EAAE,MAAM,KAAK,CAAC,OAAO,CAAC,SAAS,EAAE,MAAM,KAAK,CAAC,KAAK,EAAE;QACvE;QAEA,OAAO;IACT;IAEQ,IAAI,KAAe,EAAE,OAAe,EAAE,OAAa,EAAE,KAAa,EAAE;QAC1E,MAAM,QAAkB;YACtB;YACA;YACA,WAAW,IAAI,OAAO,WAAW;YACjC;YACA;QACF;QAEA,MAAM,eAAe,IAAI,CAAC,SAAS,CAAC;QAEpC,sCAAsC;QACtC,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,OAAQ;gBACN;oBACE,QAAQ,KAAK,CAAC;oBACd;gBACF;oBACE,QAAQ,IAAI,CAAC;oBACb;gBACF;oBACE,QAAQ,IAAI,CAAC;oBACb;gBACF;oBACE,QAAQ,KAAK,CAAC;oBACd;YACJ;QACF,OAAO;YACL,4DAA4D;YAC5D,0CAA0C;YAC1C,QAAQ,GAAG,CAAC,KAAK,SAAS,CAAC;QAC7B;IACF;IAEA,MAAM,OAAe,EAAE,KAAa,EAAE,OAAa,EAAE;QACnD,IAAI,CAAC,GAAG,UAAiB,SAAS,SAAS;IAC7C;IAEA,KAAK,OAAe,EAAE,OAAa,EAAE;QACnC,IAAI,CAAC,GAAG,SAAgB,SAAS;IACnC;IAEA,KAAK,OAAe,EAAE,OAAa,EAAE;QACnC,IAAI,CAAC,GAAG,SAAgB,SAAS;IACnC;IAEA,MAAM,OAAe,EAAE,OAAa,EAAE;QACpC,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,IAAI,CAAC,GAAG,UAAiB,SAAS;QACpC;IACF;AACF;AAEO,MAAM,SAAS,IAAI"}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/prisma.ts"],"sourcesContent":["import dotenv from 'dotenv';\r\nconst envState = `[${new Date().toISOString()}] NODE_ENV: ${process.env.NODE_ENV}, IS_PLAYWRIGHT: ${process.env.IS_PLAYWRIGHT}`;\r\ntry {\r\n  const fs = require('fs');\r\n  fs.appendFileSync('prisma_debug.log', `${envState}\\n`);\r\n} catch (e) { }\r\n\r\nif (process.env.NODE_ENV === 'test' || process.env.IS_PLAYWRIGHT === 'true') {\r\n  dotenv.config({ path: '.env.test', override: true });\r\n} else {\r\n  dotenv.config({ path: '.env.local' });\r\n}\r\n\r\nconst dbUrlLog = `[${new Date().toISOString()}] DB URL HOST: ${process.env.DATABASE_URL?.split('@')[1]?.split('/')[0] || 'unknown'}`;\r\ntry {\r\n  const fs = require('fs');\r\n  fs.appendFileSync('prisma_debug.log', `${dbUrlLog}\\n\\n`);\r\n} catch (e) { }\r\n\r\nimport { PrismaClient, Prisma } from '@prisma/client';\r\nimport { PrismaPg } from '@prisma/adapter-pg';\r\nimport { Pool } from 'pg';\r\nimport { logger } from './logger';\r\n\r\nexport { Prisma };\r\n\r\n// Prevent multiple instances of Prisma Client in development\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined;\r\n  pool: Pool | undefined;\r\n};\r\n\r\nconst connectionString = process.env.DATABASE_URL?.includes('localhost')\r\n  ? process.env.DATABASE_URL.replace('localhost', '127.0.0.1')\r\n  : process.env.DATABASE_URL;\r\n\r\nif (!connectionString) {\r\n  logger.error('DATABASE_URL is not defined in lib/prisma.ts');\r\n} else {\r\n  const host = connectionString.split('@')[1]?.split('/')[0];\r\n  const dbName = connectionString.split('/').pop()?.split('?')[0];\r\n  logger.info(`Initializing Prisma with Host: ${host}, DB: ${dbName}`);\r\n  console.log(`[DEBUG] Prisma Source: ${process.env.NODE_ENV === 'test' ? '.env.test' : '.env.local'} | Host: ${host}`);\r\n}\r\n\r\n// Create PostgreSQL connection pool\r\nconst pool = globalForPrisma.pool ?? new Pool({ connectionString });\r\nconst adapter = new PrismaPg(pool);\r\n\r\n// Optimized Prisma Client configuration\r\nconst prismaConfig: any = {\r\n  adapter,\r\n  log: [\r\n    {\r\n      emit: 'event',\r\n      level: 'query',\r\n    },\r\n    {\r\n      emit: 'event',\r\n      level: 'error',\r\n    },\r\n    {\r\n      emit: 'event',\r\n      level: 'warn',\r\n    },\r\n  ],\r\n};\r\n\r\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient(prismaConfig);\r\n\r\n// Log slow queries in development\r\nif (process.env.NODE_ENV === 'development') {\r\n  prisma.$on('query' as never, (e: any) => {\r\n    if (e.duration > 1000) {\r\n      // Log queries taking more than 1 second\r\n      logger.warn('Slow query detected', {\r\n        query: e.query,\r\n        duration: `${e.duration}ms`,\r\n        params: e.params,\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n// Log errors\r\nprisma.$on('error' as never, (e: any) => {\r\n  logger.error('Prisma error', e instanceof Error ? e : undefined, {\r\n    target: e.target,\r\n    timestamp: e.timestamp,\r\n    message: e.message,\r\n  });\r\n});\r\n\r\n// Log warnings\r\nprisma.$on('warn' as never, (e: any) => {\r\n  logger.warn('Prisma warning', {\r\n    message: e.message,\r\n    timestamp: e.timestamp,\r\n  });\r\n});\r\n\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  globalForPrisma.prisma = prisma;\r\n  if (pool) {\r\n    globalForPrisma.pool = pool;\r\n  }\r\n}\r\n\r\n// Graceful shutdown\r\nprocess.on('beforeExit', async () => {\r\n  await prisma.$disconnect();\r\n  if (pool) {\r\n    await pool.end();\r\n  }\r\n});\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/repositories/data-maintenance.repository.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma';\r\nimport {\r\n  ReferenceDataType,\r\n  CreateProductCategoryInput,\r\n  CreateExpenseCategoryInput,\r\n  CreatePaymentMethodInput,\r\n  CreateUnitOfMeasureInput,\r\n  CreateExpenseVendorInput,\r\n  UpdateProductCategoryInput,\r\n  UpdateExpenseCategoryInput,\r\n  UpdatePaymentMethodInput,\r\n  UpdateUnitOfMeasureInput,\r\n  UpdateExpenseVendorInput,\r\n  UpdateSalesAgentInput,\r\n  CreateSalesAgentInput,\r\n  ReferenceDataFilters,\r\n} from '@/types/data-maintenance.types';\r\n\r\n// Generic type for create/update inputs\r\ntype CreateInput<T extends ReferenceDataType> = T extends 'product-categories'\r\n  ? CreateProductCategoryInput\r\n  : T extends 'expense-categories'\r\n  ? CreateExpenseCategoryInput\r\n  : T extends 'payment-methods'\r\n  ? CreatePaymentMethodInput\r\n  : T extends 'units-of-measure'\r\n  ? CreateUnitOfMeasureInput\r\n  : T extends 'expense-vendors'\r\n  ? CreateExpenseVendorInput\r\n  : T extends 'sales-agents'\r\n  ? CreateSalesAgentInput\r\n  : never;\r\n\r\ntype UpdateInput<T extends ReferenceDataType> = T extends 'product-categories'\r\n  ? UpdateProductCategoryInput\r\n  : T extends 'expense-categories'\r\n  ? UpdateExpenseCategoryInput\r\n  : T extends 'payment-methods'\r\n  ? UpdatePaymentMethodInput\r\n  : T extends 'units-of-measure'\r\n  ? UpdateUnitOfMeasureInput\r\n  : T extends 'expense-vendors'\r\n  ? UpdateExpenseVendorInput\r\n  : T extends 'sales-agents'\r\n  ? UpdateSalesAgentInput\r\n  : never;\r\n\r\nexport class DataMaintenanceRepository {\r\n  // Map reference data type to Prisma model\r\n  private getModel(type: ReferenceDataType) {\r\n    switch (type) {\r\n      case 'product-categories':\r\n        return prisma.productCategory;\r\n      case 'expense-categories':\r\n        return prisma.expenseCategory;\r\n      case 'payment-methods':\r\n        return prisma.paymentMethod;\r\n      case 'units-of-measure':\r\n        return prisma.unitOfMeasure;\r\n      case 'expense-vendors':\r\n        return prisma.expenseVendor;\r\n      case 'sales-agents':\r\n        return prisma.salesAgent;\r\n      default:\r\n        throw new Error(`Unknown reference data type: ${type}`);\r\n    }\r\n  }\r\n\r\n  async findAll<T extends ReferenceDataType>(type: T, filters?: ReferenceDataFilters) {\r\n    const model = this.getModel(type);\r\n    const where: any = {};\r\n\r\n    if (filters?.status) {\r\n      where.status = filters.status;\r\n    }\r\n\r\n    if (filters?.search) {\r\n      where.name = {\r\n        contains: filters.search,\r\n        mode: 'insensitive',\r\n      };\r\n    }\r\n\r\n    return await (model as any).findMany({\r\n      where,\r\n      orderBy: [{ displayOrder: 'asc' }, { name: 'asc' }],\r\n    });\r\n  }\r\n\r\n  async findById<T extends ReferenceDataType>(type: T, id: string) {\r\n    const model = this.getModel(type);\r\n    return await (model as any).findUnique({\r\n      where: { id },\r\n    });\r\n  }\r\n\r\n  async findByCode<T extends ReferenceDataType>(type: T, code: string) {\r\n    const model = this.getModel(type);\r\n    return await (model as any).findUnique({\r\n      where: { code },\r\n    });\r\n  }\r\n\r\n  async findByName<T extends ReferenceDataType>(type: T, name: string) {\r\n    const model = this.getModel(type);\r\n    return await (model as any).findUnique({\r\n      where: { name },\r\n    });\r\n  }\r\n\r\n  async create<T extends ReferenceDataType>(type: T, data: CreateInput<T>) {\r\n    const model = this.getModel(type);\r\n    return await (model as any).create({\r\n      data: data as any,\r\n    });\r\n  }\r\n\r\n  async update<T extends ReferenceDataType>(type: T, id: string, data: UpdateInput<T>) {\r\n    const model = this.getModel(type);\r\n    return await (model as any).update({\r\n      where: { id },\r\n      data: data as any,\r\n    });\r\n  }\r\n\r\n  async delete<T extends ReferenceDataType>(type: T, id: string) {\r\n    const model = this.getModel(type);\r\n    return await (model as any).delete({\r\n      where: { id },\r\n    });\r\n  }\r\n\r\n  async count<T extends ReferenceDataType>(type: T, filters?: ReferenceDataFilters) {\r\n    const model = this.getModel(type);\r\n    const where: any = {};\r\n\r\n    if (filters?.status) {\r\n      where.status = filters.status;\r\n    }\r\n\r\n    if (filters?.search) {\r\n      where.name = {\r\n        contains: filters.search,\r\n        mode: 'insensitive',\r\n      };\r\n    }\r\n\r\n    return await (model as any).count({ where });\r\n  }\r\n\r\n  async updateDisplayOrder<T extends ReferenceDataType>(type: T, updates: { id: string; displayOrder: number }[]) {\r\n    const model = this.getModel(type);\r\n\r\n    // Use transaction to update all display orders\r\n    await prisma.$transaction(\r\n      updates.map((update) =>\r\n        (model as any).update({\r\n          where: { id: update.id },\r\n          data: { displayOrder: update.displayOrder },\r\n        })\r\n      )\r\n    );\r\n  }\r\n\r\n  // Expense Vendor specific method to increment usage count\r\n  async incrementVendorUsage(vendorId: string) {\r\n    return await prisma.expenseVendor.update({\r\n      where: { id: vendorId },\r\n      data: {\r\n        usageCount: {\r\n          increment: 1,\r\n        },\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport const dataMaintenanceRepository = new DataMaintenanceRepository();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 435, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/validations/data-maintenance.validation.ts"],"sourcesContent":["import { z } from 'zod';\r\n\r\n// Base schema for all reference data\r\nconst baseReferenceDataSchema = z.object({\r\n  name: z.string().min(1, 'Name is required').max(100, 'Name must be 100 characters or less'),\r\n  code: z\r\n    .string()\r\n    .min(1, 'Code is required')\r\n    .max(20, 'Code must be 20 characters or less')\r\n    .regex(/^[a-zA-Z0-9_-]+$/, 'Code must contain only letters, numbers, underscores, and hyphens'),\r\n  description: z.string().max(500, 'Description must be 500 characters or less').nullish().or(z.literal('')),\r\n  status: z.enum(['active', 'inactive']).default('active'),\r\n  displayOrder: z.number().int().min(0).default(0),\r\n  isSystemDefined: z.boolean().default(false),\r\n});\r\n\r\n// Product Category\r\nexport const createProductCategorySchema = baseReferenceDataSchema;\r\n\r\nexport const updateProductCategorySchema = baseReferenceDataSchema.partial();\r\n\r\n// Expense Category\r\nexport const createExpenseCategorySchema = baseReferenceDataSchema;\r\n\r\nexport const updateExpenseCategorySchema = baseReferenceDataSchema.partial();\r\n\r\n// Payment Method\r\nexport const createPaymentMethodSchema = baseReferenceDataSchema.extend({\r\n  applicableTo: z\r\n    .array(z.enum(['expense', 'pos', 'ar', 'ap']))\r\n    .min(1, 'Select at least one applicable context')\r\n    .default(['expense', 'pos', 'ar', 'ap']),\r\n});\r\n\r\nexport const updatePaymentMethodSchema = createPaymentMethodSchema.partial();\r\n\r\n// Unit of Measure\r\nexport const createUnitOfMeasureSchema = baseReferenceDataSchema;\r\n\r\nexport const updateUnitOfMeasureSchema = baseReferenceDataSchema.partial();\r\n\r\n// Expense Vendor\r\nexport const createExpenseVendorSchema = z.object({\r\n  name: z.string().min(1, 'Vendor name is required').max(200, 'Name must be 200 characters or less'),\r\n  contactPerson: z.string().max(100, 'Contact person must be 100 characters or less').nullish().or(z.literal('')),\r\n  phone: z\r\n    .string()\r\n    .max(20, 'Phone must be 20 characters or less')\r\n    .regex(/^[\\d\\s\\-\\(\\)\\+]*$/, 'Invalid phone format')\r\n    .nullish()\r\n    .or(z.literal('')),\r\n  email: z.string().email('Invalid email format').max(100, 'Email must be 100 characters or less').nullish().or(z.literal('')),\r\n  status: z.enum(['active', 'inactive']).default('active'),\r\n  displayOrder: z.number().int().min(0).default(0),\r\n});\r\n\r\nexport const updateExpenseVendorSchema = createExpenseVendorSchema.partial();\r\n\r\n// Sales Agent\r\nexport const createSalesAgentSchema = z.object({\r\n  name: z.string({ required_error: 'Agent name is required' }).min(1, 'Agent name is required').max(100, 'Name must be 100 characters or less'),\r\n  code: z\r\n    .string({ required_error: 'Code is required' })\r\n    .min(1, 'Code is required')\r\n    .max(20, 'Code must be 20 characters or less')\r\n    .regex(/^[a-zA-Z0-9_-]+$/, 'Code must contain only letters, numbers, underscores, and hyphens'),\r\n  contactPerson: z.string().max(100, 'Contact person must be 100 characters or less').nullish().or(z.literal('')),\r\n  phone: z\r\n    .string()\r\n    .max(20, 'Phone must be 20 characters or less')\r\n    .regex(/^[\\d\\s\\-\\(\\)\\+]*$/, 'Invalid phone format')\r\n    .nullish()\r\n    .or(z.literal('')),\r\n  email: z.string().email('Invalid email format').max(100, 'Email must be 100 characters or less').nullish().or(z.literal('')),\r\n  status: z.enum(['active', 'inactive']).default('active'),\r\n  displayOrder: z.number().int().min(0).default(0),\r\n});\r\n\r\nexport const updateSalesAgentSchema = createSalesAgentSchema.partial();\r\n\r\n// Validation helper type\r\nexport type CreateProductCategorySchema = z.infer<typeof createProductCategorySchema>;\r\nexport type CreateExpenseCategorySchema = z.infer<typeof createExpenseCategorySchema>;\r\nexport type CreatePaymentMethodSchema = z.infer<typeof createPaymentMethodSchema>;\r\nexport type CreateUnitOfMeasureSchema = z.infer<typeof createUnitOfMeasureSchema>;\r\nexport type CreateExpenseVendorSchema = z.infer<typeof createExpenseVendorSchema>;\r\nexport type CreateSalesAgentSchema = z.infer<typeof createSalesAgentSchema>;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 528, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/errors.ts"],"sourcesContent":["/**\r\n * Centralized Error Handling for InventoryPro\r\n * Consolidates all custom error classes and utilities\r\n */\r\n\r\nimport { Prisma } from '@prisma/client';\r\n\r\n/**\r\n * Error codes for consistent error identification\r\n */\r\nexport enum ErrorCode {\r\n  // Client Errors (4xx)\r\n  BAD_REQUEST = 'BAD_REQUEST',\r\n  UNAUTHORIZED = 'UNAUTHORIZED',\r\n  FORBIDDEN = 'FORBIDDEN',\r\n  NOT_FOUND = 'NOT_FOUND',\r\n  CONFLICT = 'CONFLICT',\r\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\r\n\r\n  // Server Errors (5xx)\r\n  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',\r\n  DATABASE_ERROR = 'DATABASE_ERROR',\r\n  EXTERNAL_SERVICE_ERROR = 'EXTERNAL_SERVICE_ERROR',\r\n\r\n  // Business Logic Errors\r\n  INSUFFICIENT_STOCK = 'INSUFFICIENT_STOCK',\r\n  DUPLICATE_ENTRY = 'DUPLICATE_ENTRY',\r\n  INVALID_OPERATION = 'INVALID_OPERATION',\r\n}\r\n\r\n/**\r\n * Base application error class\r\n * All custom errors should extend this class\r\n */\r\nexport class AppError extends Error {\r\n  public readonly statusCode: number;\r\n  public readonly code: ErrorCode;\r\n  public readonly isOperational: boolean;\r\n  public readonly details?: any;\r\n\r\n  constructor(\r\n    message: string,\r\n    statusCode: number = 500,\r\n    code: ErrorCode = ErrorCode.INTERNAL_SERVER_ERROR,\r\n    isOperational: boolean = true,\r\n    details?: any\r\n  ) {\r\n    super(message);\r\n    Object.setPrototypeOf(this, new.target.prototype);\r\n\r\n    this.statusCode = statusCode;\r\n    this.code = code;\r\n    this.isOperational = isOperational;\r\n    this.details = details;\r\n    this.name = this.constructor.name;\r\n\r\n    Error.captureStackTrace(this);\r\n  }\r\n}\r\n\r\n/**\r\n * Validation error - for invalid input data\r\n */\r\nexport class ValidationError extends AppError {\r\n  constructor(message: string, public fields?: Record<string, string | string[]>) {\r\n    super(message, 400, ErrorCode.VALIDATION_ERROR, true, fields);\r\n  }\r\n}\r\n\r\n/**\r\n * Not found error - for missing resources\r\n */\r\nexport class NotFoundError extends AppError {\r\n  constructor(resource: string, identifier?: string) {\r\n    const message = identifier\r\n      ? `${resource} with identifier '${identifier}' not found`\r\n      : `${resource} not found`;\r\n    super(message, 404, ErrorCode.NOT_FOUND, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Conflict error - for duplicate entries or conflicting operations\r\n */\r\nexport class ConflictError extends AppError {\r\n  constructor(message: string, details?: any) {\r\n    super(message, 409, ErrorCode.CONFLICT, true, details);\r\n  }\r\n}\r\n\r\n/**\r\n * Database error - for database operation failures\r\n */\r\nexport class DatabaseError extends AppError {\r\n  constructor(message: string, details?: any) {\r\n    super(message, 500, ErrorCode.DATABASE_ERROR, true, details);\r\n  }\r\n}\r\n\r\n/**\r\n * Insufficient stock error - for inventory stock issues\r\n */\r\nexport class InsufficientStockError extends AppError {\r\n  constructor(productName: string, available: number, requested: number) {\r\n    super(\r\n      `Insufficient stock for ${productName}. Available: ${available}, Requested: ${requested}`,\r\n      400,\r\n      ErrorCode.INSUFFICIENT_STOCK,\r\n      true,\r\n      { productName, available, requested }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Unauthorized error - for authentication failures\r\n */\r\nexport class UnauthorizedError extends AppError {\r\n  constructor(message: string = 'Unauthorized access') {\r\n    super(message, 401, ErrorCode.UNAUTHORIZED, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Forbidden error - for authorization failures\r\n */\r\nexport class ForbiddenError extends AppError {\r\n  constructor(message: string = 'Access forbidden') {\r\n    super(message, 403, ErrorCode.FORBIDDEN, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Prisma Error Handler\r\n * Transforms Prisma errors into user-friendly AppErrors\r\n */\r\nexport function handlePrismaError(error: unknown, context?: string): AppError {\r\n  // Log the original error for debugging\r\n  console.error('===== PRISMA ERROR =====');\r\n  console.error('Context:', context);\r\n  console.error('Error:', error);\r\n  if (error instanceof Error) {\r\n    console.error('Message:', error.message);\r\n    console.error('Stack:', error.stack);\r\n  }\r\n  if (error instanceof Prisma.PrismaClientKnownRequestError) {\r\n    console.error('Prisma Code:', error.code);\r\n    console.error('Prisma Meta:', error.meta);\r\n  }\r\n  console.error('========================');\r\n\r\n  // Prisma Client Known Request Error (e.g., unique constraint, foreign key)\r\n  if (error instanceof Prisma.PrismaClientKnownRequestError) {\r\n    switch (error.code) {\r\n      case 'P2002': {\r\n        // Unique constraint violation\r\n        const target = (error.meta?.target as string[]) || [];\r\n        const field = target[0] || 'field';\r\n        return new ConflictError(\r\n          `A record with this ${field} already exists`,\r\n          { field, code: error.code }\r\n        );\r\n      }\r\n      case 'P2003': {\r\n        // Foreign key constraint violation\r\n        const field = error.meta?.field_name as string;\r\n\r\n        // If operation is delete, it means record is in use\r\n        if (context && (context.toLowerCase().includes('delete') || context.toLowerCase().includes('remove'))) {\r\n          return new ConflictError(\r\n            `Cannot delete record because it is referenced by other data (Constraint: ${field || 'unknown'})`,\r\n            { field, code: error.code }\r\n          );\r\n        }\r\n\r\n        return new ValidationError(\r\n          `Invalid reference: ${field || 'related record'} does not exist`,\r\n          { [field || 'reference']: 'Referenced record not found' }\r\n        );\r\n      }\r\n      case 'P2025': {\r\n        // Record not found\r\n        return new NotFoundError('Record');\r\n      }\r\n      case 'P2014': {\r\n        // Required relation violation\r\n        return new ValidationError(\r\n          'Required relationship is missing',\r\n          { relation: 'Required related record is missing' }\r\n        );\r\n      }\r\n      default: {\r\n        return new DatabaseError(\r\n          `Database operation failed: ${error.code} - ${error.message}`,\r\n          { code: error.code, meta: error.meta }\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Prisma Client Validation Error (e.g., invalid query)\r\n  if (error instanceof Prisma.PrismaClientValidationError) {\r\n    return new ValidationError(`Invalid data provided to database: ${error.message}`);\r\n  }\r\n\r\n  // Prisma Client Initialization Error\r\n  if (error instanceof Prisma.PrismaClientInitializationError) {\r\n    return new DatabaseError('Database connection failed', {\r\n      code: error.errorCode,\r\n    });\r\n  }\r\n\r\n  // Prisma Client Rust Panic Error\r\n  if (error instanceof Prisma.PrismaClientRustPanicError) {\r\n    return new DatabaseError('Database engine error', {\r\n      message: error.message,\r\n    });\r\n  }\r\n\r\n  // If it's already an AppError, return it\r\n  if (error instanceof AppError) {\r\n    return error;\r\n  }\r\n\r\n  // Unknown error\r\n  return new AppError(\r\n    error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    500,\r\n    ErrorCode.INTERNAL_SERVER_ERROR,\r\n    false\r\n  );\r\n}\r\n\r\n/**\r\n * Safe error handler for repositories\r\n * Wraps repository operations and transforms errors\r\n */\r\nexport async function withErrorHandling<T>(\r\n  operation: () => Promise<T>,\r\n  context?: string\r\n): Promise<T> {\r\n  try {\r\n    return await operation();\r\n  } catch (error) {\r\n    const appError = handlePrismaError(error, context);\r\n\r\n    // Add context if provided\r\n    if (context && appError.details) {\r\n      appError.details.context = context;\r\n    }\r\n\r\n    throw appError;\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 734, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/error-logger.ts"],"sourcesContent":["/**\r\n * Error Logging Utility for InventoryPro\r\n * Provides centralized error logging with context and severity levels\r\n */\r\n\r\nexport enum LogLevel {\r\n    ERROR = 'ERROR',\r\n    WARN = 'WARN',\r\n    INFO = 'INFO',\r\n    DEBUG = 'DEBUG',\r\n}\r\n\r\nexport interface ErrorContext {\r\n    userId?: string;\r\n    requestId?: string;\r\n    path?: string;\r\n    method?: string;\r\n    timestamp?: Date;\r\n    [key: string]: any;\r\n}\r\n\r\nexport interface LogEntry {\r\n    level: LogLevel;\r\n    message: string;\r\n    error?: Error;\r\n    context?: ErrorContext;\r\n    timestamp: Date;\r\n}\r\n\r\n/**\r\n * Sanitize sensitive data from objects before logging\r\n */\r\nfunction sanitizeData(data: any): any {\r\n    if (!data || typeof data !== 'object') {\r\n        return data;\r\n    }\r\n\r\n    const sensitiveFields = [\r\n        'password',\r\n        'passwordHash',\r\n        'token',\r\n        'accessToken',\r\n        'refreshToken',\r\n        'secret',\r\n        'apiKey',\r\n        'creditCard',\r\n        'ssn',\r\n    ];\r\n\r\n    const sanitized = Array.isArray(data) ? [...data] : { ...data };\r\n\r\n    for (const key in sanitized) {\r\n        const lowerKey = key.toLowerCase();\r\n\r\n        // Check if field is sensitive\r\n        if (sensitiveFields.some(field => lowerKey.includes(field))) {\r\n            sanitized[key] = '[REDACTED]';\r\n        } else if (typeof sanitized[key] === 'object' && sanitized[key] !== null) {\r\n            // Recursively sanitize nested objects\r\n            sanitized[key] = sanitizeData(sanitized[key]);\r\n        }\r\n    }\r\n\r\n    return sanitized;\r\n}\r\n\r\n/**\r\n * Format error for logging\r\n */\r\nfunction formatError(error: Error): any {\r\n    return {\r\n        name: error.name,\r\n        message: error.message,\r\n        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,\r\n    };\r\n}\r\n\r\n/**\r\n * Error Logger Class\r\n */\r\nexport class ErrorLogger {\r\n    /**\r\n     * Log an error with context\r\n     */\r\n    static log(\r\n        level: LogLevel,\r\n        message: string,\r\n        error?: Error,\r\n        context?: ErrorContext\r\n    ): void {\r\n        const entry: LogEntry = {\r\n            level,\r\n            message,\r\n            error,\r\n            context: context ? sanitizeData(context) : undefined,\r\n            timestamp: new Date(),\r\n        };\r\n\r\n        // In production, you might want to send this to an external logging service\r\n        // For now, we'll use console with appropriate methods\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                console.error('[ERROR]', message, {\r\n                    error: error ? formatError(error) : undefined,\r\n                    context: entry.context,\r\n                    timestamp: entry.timestamp.toISOString(),\r\n                });\r\n                break;\r\n            case LogLevel.WARN:\r\n                console.warn('[WARN]', message, {\r\n                    context: entry.context,\r\n                    timestamp: entry.timestamp.toISOString(),\r\n                });\r\n                break;\r\n            case LogLevel.INFO:\r\n                console.info('[INFO]', message, {\r\n                    context: entry.context,\r\n                    timestamp: entry.timestamp.toISOString(),\r\n                });\r\n                break;\r\n            case LogLevel.DEBUG:\r\n                if (process.env.NODE_ENV === 'development') {\r\n                    console.debug('[DEBUG]', message, {\r\n                        context: entry.context,\r\n                        timestamp: entry.timestamp.toISOString(),\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Log an error\r\n     */\r\n    static error(message: string, error?: Error, context?: ErrorContext): void {\r\n        this.log(LogLevel.ERROR, message, error, context);\r\n    }\r\n\r\n    /**\r\n     * Log a warning\r\n     */\r\n    static warn(message: string, context?: ErrorContext): void {\r\n        this.log(LogLevel.WARN, message, undefined, context);\r\n    }\r\n\r\n    /**\r\n     * Log info\r\n     */\r\n    static info(message: string, context?: ErrorContext): void {\r\n        this.log(LogLevel.INFO, message, undefined, context);\r\n    }\r\n\r\n    /**\r\n     * Log debug information (only in development)\r\n     */\r\n    static debug(message: string, context?: ErrorContext): void {\r\n        this.log(LogLevel.DEBUG, message, undefined, context);\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to create error context from request\r\n */\r\nexport function createErrorContext(\r\n    request?: Request,\r\n    additionalContext?: Record<string, any>\r\n): ErrorContext {\r\n    const context: ErrorContext = {\r\n        timestamp: new Date(),\r\n        ...additionalContext,\r\n    };\r\n\r\n    if (request) {\r\n        const url = new URL(request.url);\r\n        context.path = url.pathname;\r\n        context.method = request.method;\r\n\r\n        // Try to extract request ID if available\r\n        const requestId = request.headers.get('x-request-id');\r\n        if (requestId) {\r\n            context.requestId = requestId;\r\n        }\r\n    }\r\n\r\n    return context;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 880, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/lib/api-error.ts"],"sourcesContent":["/**\r\n * API Error Handling Utilities\r\n * Provides error response formatting and async handler wrapper for API routes\r\n */\r\n\r\nimport { ZodError } from 'zod';\r\nimport {\r\n  AppError,\r\n  ErrorCode,\r\n  ValidationError,\r\n  handlePrismaError\r\n} from './errors';\r\nimport { ErrorLogger, createErrorContext } from './error-logger';\r\n\r\n/**\r\n * Error Response Interface\r\n */\r\nexport interface ErrorResponse {\r\n  success: false;\r\n  error: {\r\n    code: ErrorCode;\r\n    message: string;\r\n    details?: any;\r\n    fields?: Record<string, string | string[]>;\r\n    stack?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Format Zod validation errors into user-friendly messages\r\n */\r\nfunction formatZodError(error: ZodError): { message: string; fields: Record<string, string[]> } {\r\n  const fields: Record<string, string[]> = {};\r\n\r\n  error.errors.forEach(err => {\r\n    const path = err.path.join('.');\r\n    const message = err.message;\r\n\r\n    if (!fields[path]) {\r\n      fields[path] = [];\r\n    }\r\n    fields[path].push(message);\r\n  });\r\n\r\n  return {\r\n    message: 'Validation failed',\r\n    fields,\r\n  };\r\n}\r\n\r\n/**\r\n * Format error response for API\r\n */\r\nexport function formatErrorResponse(error: Error, includeStack: boolean = false): ErrorResponse {\r\n  // Handle Zod validation errors\r\n  if (error instanceof ZodError) {\r\n    const { message, fields } = formatZodError(error);\r\n    return {\r\n      success: false,\r\n      error: {\r\n        code: ErrorCode.VALIDATION_ERROR,\r\n        message,\r\n        fields,\r\n        ...(includeStack && { stack: error.stack }),\r\n      },\r\n    };\r\n  }\r\n\r\n  // Handle custom AppErrors\r\n  if (error instanceof AppError) {\r\n    return {\r\n      success: false,\r\n      error: {\r\n        code: error.code,\r\n        message: error.message,\r\n        details: error.details,\r\n        ...(includeStack && { stack: error.stack }),\r\n      },\r\n    };\r\n  }\r\n\r\n  // Handle Prisma errors\r\n  if (error.constructor.name.includes('Prisma')) {\r\n    const appError = handlePrismaError(error);\r\n    return {\r\n      success: false,\r\n      error: {\r\n        code: appError.code,\r\n        message: appError.message,\r\n        details: appError.details,\r\n        ...(includeStack && { stack: error.stack }),\r\n      },\r\n    };\r\n  }\r\n\r\n  // Generic error\r\n  return {\r\n    success: false,\r\n    error: {\r\n      code: ErrorCode.INTERNAL_SERVER_ERROR,\r\n      message: process.env.NODE_ENV === 'production'\r\n        ? 'An unexpected error occurred'\r\n        : error.message,\r\n      ...(includeStack && { stack: error.stack }),\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Async Handler Wrapper for API Routes\r\n * Catches errors and formats them consistently\r\n * \r\n * Usage:\r\n * export const GET = asyncHandler(async (request: Request) => {\r\n *   const data = await service.getData();\r\n *   return Response.json({ success: true, data });\r\n * });\r\n */\r\nexport function asyncHandler(\r\n  handler: (req: Request, context?: any) => Promise<Response>\r\n) {\r\n  return async (req: Request, context?: any): Promise<Response> => {\r\n    try {\r\n      return await handler(req, context);\r\n    } catch (error: any) {\r\n      // Log the error with context\r\n      const errorContext = createErrorContext(req, {\r\n        handler: handler.name || 'anonymous',\r\n      });\r\n\r\n      ErrorLogger.error(\r\n        'API request failed',\r\n        error instanceof Error ? error : new Error(String(error)),\r\n        errorContext\r\n      );\r\n\r\n      // Format error response\r\n      const includeStack = process.env.NODE_ENV === 'development';\r\n      const errorResponse = formatErrorResponse(\r\n        error instanceof Error ? error : new Error(String(error)),\r\n        includeStack\r\n      );\r\n\r\n      // Determine status code\r\n      const statusCode = error instanceof AppError ? error.statusCode : 500;\r\n\r\n      return Response.json(errorResponse, { status: statusCode });\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Re-export error classes for convenience\r\n */\r\nexport {\r\n  AppError,\r\n  ValidationError,\r\n  NotFoundError,\r\n  ConflictError,\r\n  DatabaseError,\r\n  InsufficientStockError,\r\n  UnauthorizedError,\r\n  ForbiddenError,\r\n  ErrorCode,\r\n} from './errors';\r\n\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED;AACA;AAMA;;;;AAgBA;;CAEC,GACD,SAAS,eAAe,KAAe;IACrC,MAAM,SAAmC,CAAC;IAE1C,MAAM,MAAM,CAAC,OAAO,CAAC,CAAA;QACnB,MAAM,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC;QAC3B,MAAM,UAAU,IAAI,OAAO;QAE3B,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE;YACjB,MAAM,CAAC,KAAK,GAAG,EAAE;QACnB;QACA,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC;IACpB;IAEA,OAAO;QACL,SAAS;QACT;IACF;AACF;AAKO,SAAS,oBAAoB,KAAY,EAAE,eAAwB,KAAK;IAC7E,+BAA+B;IAC/B,IAAI,iBAAiB,sLAAQ,EAAE;QAC7B,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,eAAe;QAC3C,OAAO;YACL,SAAS;YACT,OAAO;gBACL,MAAM,+JAAS,CAAC,gBAAgB;gBAChC;gBACA;gBACA,GAAI,gBAAgB;oBAAE,OAAO,MAAM,KAAK;gBAAC,CAAC;YAC5C;QACF;IACF;IAEA,0BAA0B;IAC1B,IAAI,iBAAiB,8JAAQ,EAAE;QAC7B,OAAO;YACL,SAAS;YACT,OAAO;gBACL,MAAM,MAAM,IAAI;gBAChB,SAAS,MAAM,OAAO;gBACtB,SAAS,MAAM,OAAO;gBACtB,GAAI,gBAAgB;oBAAE,OAAO,MAAM,KAAK;gBAAC,CAAC;YAC5C;QACF;IACF;IAEA,uBAAuB;IACvB,IAAI,MAAM,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW;QAC7C,MAAM,WAAW,IAAA,uKAAiB,EAAC;QACnC,OAAO;YACL,SAAS;YACT,OAAO;gBACL,MAAM,SAAS,IAAI;gBACnB,SAAS,SAAS,OAAO;gBACzB,SAAS,SAAS,OAAO;gBACzB,GAAI,gBAAgB;oBAAE,OAAO,MAAM,KAAK;gBAAC,CAAC;YAC5C;QACF;IACF;IAEA,gBAAgB;IAChB,OAAO;QACL,SAAS;QACT,OAAO;YACL,MAAM,+JAAS,CAAC,qBAAqB;YACrC,SAAS,sCACL,0BACA,MAAM,OAAO;YACjB,GAAI,gBAAgB;gBAAE,OAAO,MAAM,KAAK;YAAC,CAAC;QAC5C;IACF;AACF;AAYO,SAAS,aACd,OAA2D;IAE3D,OAAO,OAAO,KAAc;QAC1B,IAAI;YACF,OAAO,MAAM,QAAQ,KAAK;QAC5B,EAAE,OAAO,OAAY;YACnB,6BAA6B;YAC7B,MAAM,eAAe,IAAA,iLAAkB,EAAC,KAAK;gBAC3C,SAAS,QAAQ,IAAI,IAAI;YAC3B;YAEA,0KAAW,CAAC,KAAK,CACf,sBACA,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,SAClD;YAGF,wBAAwB;YACxB,MAAM,eAAe,oDAAyB;YAC9C,MAAM,gBAAgB,oBACpB,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,SAClD;YAGF,wBAAwB;YACxB,MAAM,aAAa,iBAAiB,8JAAQ,GAAG,MAAM,UAAU,GAAG;YAElE,OAAO,SAAS,IAAI,CAAC,eAAe;gBAAE,QAAQ;YAAW;QAC3D;IACF;AACF"}},
    {"offset": {"line": 997, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/services/data-maintenance.service.ts"],"sourcesContent":["import { dataMaintenanceRepository } from '@/repositories/data-maintenance.repository';\r\nimport {\r\n  ReferenceDataType,\r\n  CreateProductCategoryInput,\r\n  CreateExpenseCategoryInput,\r\n  CreatePaymentMethodInput,\r\n  CreateUnitOfMeasureInput,\r\n  CreateExpenseVendorInput,\r\n  CreateSalesAgentInput,\r\n  UpdateProductCategoryInput,\r\n  UpdateExpenseCategoryInput,\r\n  UpdatePaymentMethodInput,\r\n  UpdateUnitOfMeasureInput,\r\n  UpdateExpenseVendorInput,\r\n  UpdateSalesAgentInput,\r\n  ReferenceDataFilters,\r\n} from '@/types/data-maintenance.types';\r\nimport {\r\n  createProductCategorySchema,\r\n  updateProductCategorySchema,\r\n  createExpenseCategorySchema,\r\n  updateExpenseCategorySchema,\r\n  createPaymentMethodSchema,\r\n  updatePaymentMethodSchema,\r\n  createUnitOfMeasureSchema,\r\n  updateUnitOfMeasureSchema,\r\n  createExpenseVendorSchema,\r\n  updateExpenseVendorSchema,\r\n  createSalesAgentSchema,\r\n  updateSalesAgentSchema,\r\n} from '@/lib/validations/data-maintenance.validation';\r\nimport { ValidationError, NotFoundError } from '@/lib/api-error';\r\n\r\n// Generic type for create/update inputs\r\ntype CreateInput<T extends ReferenceDataType> = T extends 'product-categories'\r\n  ? CreateProductCategoryInput\r\n  : T extends 'expense-categories'\r\n  ? CreateExpenseCategoryInput\r\n  : T extends 'payment-methods'\r\n  ? CreatePaymentMethodInput\r\n  : T extends 'units-of-measure'\r\n  ? CreateUnitOfMeasureInput\r\n  : T extends 'expense-vendors'\r\n  ? CreateExpenseVendorInput\r\n  : T extends 'sales-agents'\r\n  ? CreateSalesAgentInput\r\n  : never;\r\n\r\ntype UpdateInput<T extends ReferenceDataType> = T extends 'product-categories'\r\n  ? UpdateProductCategoryInput\r\n  : T extends 'expense-categories'\r\n  ? UpdateExpenseCategoryInput\r\n  : T extends 'payment-methods'\r\n  ? UpdatePaymentMethodInput\r\n  : T extends 'units-of-measure'\r\n  ? UpdateUnitOfMeasureInput\r\n  : T extends 'expense-vendors'\r\n  ? UpdateExpenseVendorInput\r\n  : T extends 'sales-agents'\r\n  ? UpdateSalesAgentInput\r\n  : never;\r\n\r\nexport class DataMaintenanceService {\r\n  // Get validation schema for create\r\n  private getCreateSchema(type: ReferenceDataType) {\r\n    switch (type) {\r\n      case 'product-categories':\r\n        return createProductCategorySchema;\r\n      case 'expense-categories':\r\n        return createExpenseCategorySchema;\r\n      case 'payment-methods':\r\n        return createPaymentMethodSchema;\r\n      case 'units-of-measure':\r\n        return createUnitOfMeasureSchema;\r\n      case 'expense-vendors':\r\n        return createExpenseVendorSchema;\r\n      case 'sales-agents':\r\n        return createSalesAgentSchema;\r\n      default:\r\n        throw new Error(`Unknown reference data type: ${type}`);\r\n    }\r\n  }\r\n\r\n  // Get validation schema for update\r\n  private getUpdateSchema(type: ReferenceDataType) {\r\n    switch (type) {\r\n      case 'product-categories':\r\n        return updateProductCategorySchema;\r\n      case 'expense-categories':\r\n        return updateExpenseCategorySchema;\r\n      case 'payment-methods':\r\n        return updatePaymentMethodSchema;\r\n      case 'units-of-measure':\r\n        return updateUnitOfMeasureSchema;\r\n      case 'expense-vendors':\r\n        return updateExpenseVendorSchema;\r\n      case 'sales-agents':\r\n        return updateSalesAgentSchema;\r\n      default:\r\n        throw new Error(`Unknown reference data type: ${type}`);\r\n    }\r\n  }\r\n\r\n  // Get human-readable name for the type\r\n  private getTypeName(type: ReferenceDataType): string {\r\n    switch (type) {\r\n      case 'product-categories':\r\n        return 'Product Category';\r\n      case 'expense-categories':\r\n        return 'Expense Category';\r\n      case 'payment-methods':\r\n        return 'Payment Method';\r\n      case 'units-of-measure':\r\n        return 'Unit of Measure';\r\n      case 'expense-vendors':\r\n        return 'Expense Vendor';\r\n      case 'sales-agents':\r\n        return 'Sales Agent';\r\n      default:\r\n        return 'Reference Data';\r\n    }\r\n  }\r\n\r\n  async getAll<T extends ReferenceDataType>(type: T, filters?: ReferenceDataFilters) {\r\n    return await dataMaintenanceRepository.findAll(type, filters);\r\n  }\r\n\r\n  async getById<T extends ReferenceDataType>(type: T, id: string) {\r\n    const item = await dataMaintenanceRepository.findById(type, id);\r\n    if (!item) {\r\n      throw new NotFoundError(this.getTypeName(type));\r\n    }\r\n    return item;\r\n  }\r\n\r\n  async create<T extends ReferenceDataType>(type: T, data: CreateInput<T>) {\r\n    // Validate input\r\n    const schema = this.getCreateSchema(type);\r\n    const validationResult = schema.safeParse(data);\r\n\r\n    if (!validationResult.success) {\r\n      const errors = validationResult.error.flatten().fieldErrors;\r\n      throw new ValidationError('Invalid data', errors);\r\n    }\r\n\r\n    const validatedData = validationResult.data;\r\n\r\n    // Check for duplicate name\r\n    const existingByName = await dataMaintenanceRepository.findByName(type, validatedData.name);\r\n    if (existingByName) {\r\n      throw new ValidationError('A record with this name already exists', {\r\n        name: ['Name must be unique'],\r\n      });\r\n    }\r\n\r\n    // Check for duplicate code (if code exists in the data)\r\n    if ('code' in validatedData) {\r\n      const existingByCode = await dataMaintenanceRepository.findByCode(type, (validatedData as any).code);\r\n      if (existingByCode) {\r\n        throw new ValidationError('A record with this code already exists', {\r\n          code: ['Code must be unique'],\r\n        });\r\n      }\r\n    }\r\n\r\n    return await dataMaintenanceRepository.create(type, {\r\n      ...validatedData,\r\n      updatedAt: new Date(),\r\n    } as any);\r\n  }\r\n\r\n  async update<T extends ReferenceDataType>(type: T, id: string, data: UpdateInput<T>) {\r\n    // Check if item exists\r\n    const existing = await this.getById(type, id);\r\n\r\n    // Validate input\r\n    const schema = this.getUpdateSchema(type);\r\n    const validationResult = schema.safeParse(data);\r\n\r\n    if (!validationResult.success) {\r\n      const errors = validationResult.error.flatten().fieldErrors;\r\n      throw new ValidationError('Invalid data', errors);\r\n    }\r\n\r\n    const validatedData = validationResult.data;\r\n\r\n    // Check for duplicate name (if name is being updated)\r\n    if (validatedData.name && validatedData.name !== (existing as any).name) {\r\n      const existingByName = await dataMaintenanceRepository.findByName(type, validatedData.name);\r\n      if (existingByName) {\r\n        throw new ValidationError('A record with this name already exists', {\r\n          name: ['Name must be unique'],\r\n        });\r\n      }\r\n    }\r\n\r\n    // Check for duplicate code (if code is being updated and exists in the data)\r\n    if ('code' in validatedData && validatedData.code && validatedData.code !== (existing as any).code) {\r\n      const existingByCode = await dataMaintenanceRepository.findByCode(type, (validatedData as any).code);\r\n      if (existingByCode) {\r\n        throw new ValidationError('A record with this code already exists', {\r\n          code: ['Code must be unique'],\r\n        });\r\n      }\r\n    }\r\n\r\n    return await dataMaintenanceRepository.update(type, id, {\r\n      ...validatedData,\r\n      updatedAt: new Date(),\r\n    } as any);\r\n  }\r\n\r\n  async delete<T extends ReferenceDataType>(type: T, id: string) {\r\n    // Check if item exists\r\n    const existing = await this.getById(type, id);\r\n\r\n    // Prevent deletion of system-defined records\r\n    if ('isSystemDefined' in existing && (existing as any).isSystemDefined) {\r\n      throw new ValidationError('Cannot delete system-defined records', {\r\n        _general: ['This is a system-defined record and cannot be deleted'],\r\n      });\r\n    }\r\n\r\n    return await dataMaintenanceRepository.delete(type, id);\r\n  }\r\n\r\n  async updateDisplayOrder<T extends ReferenceDataType>(\r\n    type: T,\r\n    updates: { id: string; displayOrder: number }[]\r\n  ) {\r\n    // Verify all items exist\r\n    for (const update of updates) {\r\n      await this.getById(type, update.id);\r\n    }\r\n\r\n    return await dataMaintenanceRepository.updateDisplayOrder(type, updates);\r\n  }\r\n\r\n  async toggleStatus<T extends ReferenceDataType>(type: T, id: string) {\r\n    const existing = await this.getById(type, id);\r\n    const newStatus = (existing as any).status === 'active' ? 'inactive' : 'active';\r\n\r\n    return await dataMaintenanceRepository.update(type, id, { status: newStatus } as UpdateInput<T>);\r\n  }\r\n}\r\n\r\nexport const dataMaintenanceService = new DataMaintenanceService();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1208, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/repositories/user.repository.ts"],"sourcesContent":["import { Prisma } from '@prisma/client';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { UserFilters } from '@/types/user.types';\r\n\r\nexport class UserRepository {\r\n  /**\r\n   * Find all users with optional filters and pagination\r\n   */\r\n  async findAll(filters?: UserFilters, page = 1, limit = 20) {\r\n    const where: Prisma.UserWhereInput = {};\r\n\r\n    if (!filters?.includeSuperMegaAdmin) {\r\n      where.isSuperMegaAdmin = false;\r\n\r\n      // Force exclusion of primary admin email if not specifically requested\r\n      // This acts as a safeguard against filter logic bypass\r\n      const adminEmail = 'cybergada@gmail.com';\r\n      const adminExclusion = { email: { equals: adminEmail, mode: 'insensitive' as Prisma.QueryMode } };\r\n\r\n      if (where.NOT) {\r\n        if (Array.isArray(where.NOT)) {\r\n          where.NOT.push(adminExclusion);\r\n        } else {\r\n          where.NOT = [where.NOT as Prisma.UserWhereInput, adminExclusion];\r\n        }\r\n      } else {\r\n        where.NOT = adminExclusion;\r\n      }\r\n    }\r\n\r\n    if (filters?.search) {\r\n      where.OR = [\r\n        { email: { contains: filters.search, mode: 'insensitive' } },\r\n        { firstName: { contains: filters.search, mode: 'insensitive' } },\r\n        { lastName: { contains: filters.search, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.roleId) {\r\n      where.roleId = filters.roleId;\r\n    }\r\n\r\n    if (filters?.branchId) {\r\n      where.branchId = filters.branchId;\r\n    }\r\n\r\n    if (filters?.status) {\r\n      where.status = filters.status;\r\n    }\r\n\r\n    if (filters?.emailVerified !== undefined) {\r\n      where.emailVerified = filters.emailVerified;\r\n    }\r\n\r\n    if (filters?.excludeEmail) {\r\n      where.NOT = {\r\n        email: { equals: filters.excludeEmail, mode: 'insensitive' }\r\n      };\r\n    }\r\n\r\n    console.log('DEBUG REPO: filters received:', JSON.stringify(filters));\r\n    console.log('DEBUG REPO: where clause:', JSON.stringify(where));\r\n\r\n    const [users, total] = await Promise.all([\r\n      prisma.user.findMany({\r\n        where,\r\n        include: {\r\n          Role: true,\r\n          Branch: true,\r\n        },\r\n        skip: (page - 1) * limit,\r\n        take: limit,\r\n        orderBy: { createdAt: 'desc' },\r\n      }),\r\n      prisma.user.count({ where }),\r\n    ]);\r\n\r\n    return {\r\n      data: users,\r\n      total,\r\n      page,\r\n      limit,\r\n      totalPages: Math.ceil(total / limit),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find user by ID\r\n   */\r\n  async findById(userId: string) {\r\n    return prisma.user.findUnique({\r\n      where: { id: userId },\r\n      include: {\r\n        Role: {\r\n          include: {\r\n            RolePermission: {\r\n              include: {\r\n                Permission: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        Branch: true,\r\n        UserBranchAccess: {\r\n          include: {\r\n            Branch: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find user by email\r\n   */\r\n  async findByEmail(email: string) {\r\n    return prisma.user.findUnique({\r\n      where: { email },\r\n      include: {\r\n        Role: {\r\n          include: {\r\n            RolePermission: {\r\n              include: {\r\n                Permission: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        Branch: true,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create new user\r\n   */\r\n  async create(data: Prisma.UserCreateInput) {\r\n    return prisma.user.create({\r\n      data,\r\n      include: {\r\n        Role: true,\r\n        Branch: true,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update user\r\n   */\r\n  async update(userId: string, data: Prisma.UserUpdateInput) {\r\n    return prisma.user.update({\r\n      where: { id: userId },\r\n      data,\r\n      include: {\r\n        Role: true,\r\n        Branch: true,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete user\r\n   */\r\n  async delete(userId: string) {\r\n    return prisma.user.delete({\r\n      where: { id: userId },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update user status\r\n   */\r\n  async updateStatus(userId: string, status: string) {\r\n    return prisma.user.update({\r\n      where: { id: userId },\r\n      data: { status },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update last login timestamp\r\n   */\r\n  async updateLastLogin(userId: string) {\r\n    return prisma.user.update({\r\n      where: { id: userId },\r\n      data: { lastLoginAt: new Date() },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update password\r\n   */\r\n  async updatePassword(userId: string, passwordHash: string) {\r\n    return prisma.user.update({\r\n      where: { id: userId },\r\n      data: {\r\n        passwordHash,\r\n        passwordChangedAt: new Date(),\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update email verified status\r\n   */\r\n  async updateEmailVerified(userId: string, verified: boolean) {\r\n    return prisma.user.update({\r\n      where: { id: userId },\r\n      data: { emailVerified: verified },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find users by branch\r\n   */\r\n  async findByBranch(branchId: string) {\r\n    return prisma.user.findMany({\r\n      where: { branchId },\r\n      include: {\r\n        Role: true,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find users by role\r\n   */\r\n  async findByRole(roleId: string) {\r\n    return prisma.user.findMany({\r\n      where: { roleId },\r\n      include: {\r\n        Branch: true,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if email exists\r\n   */\r\n  async emailExists(email: string, excludeUserId?: string) {\r\n    const where: Prisma.UserWhereInput = { email };\r\n\r\n    if (excludeUserId) {\r\n      where.id = { not: excludeUserId };\r\n    }\r\n\r\n    const count = await prisma.user.count({ where });\r\n    return count > 0;\r\n  }\r\n}\r\n\r\nexport const userRepository = new UserRepository();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1497, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/repositories/session.repository.ts"],"sourcesContent":["import { Session, Prisma } from '@prisma/client';\r\nimport { randomUUID } from 'crypto';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { CreateSessionInput, SessionFilters } from '@/types/session.types';\r\n\r\nexport class SessionRepository {\r\n  /**\r\n   * Create new session\r\n   */\r\n  async create(data: CreateSessionInput) {\r\n    return prisma.session.create({\r\n      data: { id: randomUUID(), ...data },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find session by token\r\n   */\r\n  async findByToken(token: string) {\r\n    return prisma.session.findUnique({\r\n      where: { token },\r\n      include: {\r\n        User: {\r\n          include: {\r\n            Role: {\r\n              include: {\r\n                RolePermission: {\r\n                  include: {\r\n                    Permission: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            Branch: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find sessions by user\r\n   */\r\n  async findByUser(userId: string, filters?: SessionFilters) {\r\n    const where: Prisma.SessionWhereInput = { userId };\r\n\r\n    if (filters?.expired !== undefined) {\r\n      if (filters.expired) {\r\n        where.expiresAt = { lte: new Date() };\r\n      } else {\r\n        where.expiresAt = { gt: new Date() };\r\n      }\r\n    }\r\n\r\n    return prisma.session.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete session by token\r\n   */\r\n  async deleteByToken(token: string) {\r\n    try {\r\n      return await prisma.session.delete({\r\n        where: { token },\r\n      });\r\n    } catch (error: any) {\r\n      if (error.code === 'P2025') {\r\n        return null; // Session already deleted\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete all sessions for a user\r\n   */\r\n  async deleteByUser(userId: string) {\r\n    return prisma.session.deleteMany({\r\n      where: { userId },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete all sessions for users with a specific role\r\n   */\r\n  async deleteByRoleId(roleId: string) {\r\n    return prisma.session.deleteMany({\r\n      where: {\r\n        User: {\r\n          roleId,\r\n        },\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete expired sessions\r\n   */\r\n  async deleteExpired() {\r\n    return prisma.session.deleteMany({\r\n      where: {\r\n        expiresAt: { lte: new Date() },\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update session expiration\r\n   */\r\n  async updateExpiration(sessionId: string, expiresAt: Date) {\r\n    return prisma.session.update({\r\n      where: { id: sessionId },\r\n      data: { expiresAt },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if session is valid\r\n   */\r\n  async isValid(token: string) {\r\n    const session = await prisma.session.findUnique({\r\n      where: { token },\r\n    });\r\n\r\n    if (!session) return false;\r\n\r\n    return session.expiresAt > new Date();\r\n  }\r\n\r\n  /**\r\n   * Count active sessions for a user\r\n   */\r\n  async countActiveByUser(userId: string) {\r\n    return prisma.session.count({\r\n      where: {\r\n        userId,\r\n        expiresAt: { gt: new Date() },\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport const sessionRepository = new SessionRepository();\r\n"],"names":[],"mappings":";;;;;;AACA;AACA;;;;;;;AAGO,MAAM;IACX;;GAEC,GACD,MAAM,OAAO,IAAwB,EAAE;QACrC,OAAO,4KAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC3B,MAAM;gBAAE,IAAI,IAAA,mHAAU;gBAAI,GAAG,IAAI;YAAC;QACpC;IACF;IAEA;;GAEC,GACD,MAAM,YAAY,KAAa,EAAE;QAC/B,OAAO,4KAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC/B,OAAO;gBAAE;YAAM;YACf,SAAS;gBACP,MAAM;oBACJ,SAAS;wBACP,MAAM;4BACJ,SAAS;gCACP,gBAAgB;oCACd,SAAS;wCACP,YAAY;oCACd;gCACF;4BACF;wBACF;wBACA,QAAQ;oBACV;gBACF;YACF;QACF;IACF;IAEA;;GAEC,GACD,MAAM,WAAW,MAAc,EAAE,OAAwB,EAAE;QACzD,MAAM,QAAkC;YAAE;QAAO;QAEjD,IAAI,SAAS,YAAY,WAAW;YAClC,IAAI,QAAQ,OAAO,EAAE;gBACnB,MAAM,SAAS,GAAG;oBAAE,KAAK,IAAI;gBAAO;YACtC,OAAO;gBACL,MAAM,SAAS,GAAG;oBAAE,IAAI,IAAI;gBAAO;YACrC;QACF;QAEA,OAAO,4KAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAC7B;YACA,SAAS;gBAAE,WAAW;YAAO;QAC/B;IACF;IAEA;;GAEC,GACD,MAAM,cAAc,KAAa,EAAE;QACjC,IAAI;YACF,OAAO,MAAM,4KAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gBACjC,OAAO;oBAAE;gBAAM;YACjB;QACF,EAAE,OAAO,OAAY;YACnB,IAAI,MAAM,IAAI,KAAK,SAAS;gBAC1B,OAAO,MAAM,0BAA0B;YACzC;YACA,MAAM;QACR;IACF;IAEA;;GAEC,GACD,MAAM,aAAa,MAAc,EAAE;QACjC,OAAO,4KAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC/B,OAAO;gBAAE;YAAO;QAClB;IACF;IAEA;;GAEC,GACD,MAAM,eAAe,MAAc,EAAE;QACnC,OAAO,4KAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC/B,OAAO;gBACL,MAAM;oBACJ;gBACF;YACF;QACF;IACF;IAEA;;GAEC,GACD,MAAM,gBAAgB;QACpB,OAAO,4KAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC/B,OAAO;gBACL,WAAW;oBAAE,KAAK,IAAI;gBAAO;YAC/B;QACF;IACF;IAEA;;GAEC,GACD,MAAM,iBAAiB,SAAiB,EAAE,SAAe,EAAE;QACzD,OAAO,4KAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC3B,OAAO;gBAAE,IAAI;YAAU;YACvB,MAAM;gBAAE;YAAU;QACpB;IACF;IAEA;;GAEC,GACD,MAAM,QAAQ,KAAa,EAAE;QAC3B,MAAM,UAAU,MAAM,4KAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9C,OAAO;gBAAE;YAAM;QACjB;QAEA,IAAI,CAAC,SAAS,OAAO;QAErB,OAAO,QAAQ,SAAS,GAAG,IAAI;IACjC;IAEA;;GAEC,GACD,MAAM,kBAAkB,MAAc,EAAE;QACtC,OAAO,4KAAM,CAAC,OAAO,CAAC,KAAK,CAAC;YAC1B,OAAO;gBACL;gBACA,WAAW;oBAAE,IAAI,IAAI;gBAAO;YAC9B;QACF;IACF;AACF;AAEO,MAAM,oBAAoB,IAAI"}},
    {"offset": {"line": 1662, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/repositories/audit-log.repository.ts"],"sourcesContent":["import { Prisma } from '@prisma/client';\r\nimport { randomUUID } from 'crypto';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { CreateAuditLogInput, AuditLogFilters } from '@/types/audit.types';\r\n\r\nexport class AuditLogRepository {\r\n  /**\r\n   * Create audit log entry\r\n   */\r\n  async create(data: CreateAuditLogInput, tx?: Prisma.TransactionClient) {\r\n    const db = tx || prisma;\r\n    return db.auditLog.create({\r\n      data: {\r\n        id: randomUUID(),\r\n        userId: data.userId,\r\n        action: data.action,\r\n        resource: data.resource,\r\n        resourceId: data.resourceId,\r\n\r\n        details: data.details,\r\n        ipAddress: data.ipAddress,\r\n        userAgent: data.userAgent,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find all audit logs with filters and pagination\r\n   */\r\n  async findAll(filters?: AuditLogFilters, page = 1, limit = 50) {\r\n    const where: Prisma.AuditLogWhereInput = {};\r\n\r\n    if (filters?.userId) {\r\n      where.userId = filters.userId;\r\n    }\r\n\r\n    if (filters?.resource) {\r\n      where.resource = filters.resource;\r\n    }\r\n\r\n    if (filters?.resourceId) {\r\n      where.resourceId = filters.resourceId;\r\n    }\r\n\r\n    if (filters?.action) {\r\n      where.action = filters.action;\r\n    }\r\n\r\n    if (filters?.startDate || filters?.endDate) {\r\n      where.createdAt = {};\r\n      if (filters.startDate) {\r\n        where.createdAt.gte = filters.startDate;\r\n      }\r\n      if (filters.endDate) {\r\n        where.createdAt.lte = filters.endDate;\r\n      }\r\n    }\r\n\r\n    const [logs, total] = await Promise.all([\r\n      prisma.auditLog.findMany({\r\n        where,\r\n        include: {\r\n          User: {\r\n            select: {\r\n              id: true,\r\n              email: true,\r\n              firstName: true,\r\n              lastName: true,\r\n            },\r\n          },\r\n        },\r\n        skip: (page - 1) * limit,\r\n        take: limit,\r\n        orderBy: { createdAt: 'desc' },\r\n      }),\r\n      prisma.auditLog.count({ where }),\r\n    ]);\r\n\r\n    return {\r\n      data: logs,\r\n      total,\r\n      page,\r\n      limit,\r\n      totalPages: Math.ceil(total / limit),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find audit log by ID\r\n   */\r\n  async findById(logId: string) {\r\n    return prisma.auditLog.findUnique({\r\n      where: { id: logId },\r\n      include: {\r\n        User: {\r\n          select: {\r\n            id: true,\r\n            email: true,\r\n            firstName: true,\r\n            lastName: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find audit logs by user\r\n   */\r\n  async findByUser(userId: string, filters?: AuditLogFilters) {\r\n    const where: Prisma.AuditLogWhereInput = { userId };\r\n\r\n    if (filters?.resource) {\r\n      where.resource = filters.resource;\r\n    }\r\n\r\n    if (filters?.action) {\r\n      where.action = filters.action;\r\n    }\r\n\r\n    return prisma.auditLog.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n      take: 100,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find audit logs by resource\r\n   */\r\n  async findByResource(resource: string, resourceId?: string) {\r\n    const where: Prisma.AuditLogWhereInput = { resource };\r\n\r\n    if (resourceId) {\r\n      where.resourceId = resourceId;\r\n    }\r\n\r\n    return prisma.auditLog.findMany({\r\n      where,\r\n      include: {\r\n        User: {\r\n          select: {\r\n            id: true,\r\n            email: true,\r\n            firstName: true,\r\n            lastName: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: { createdAt: 'desc' },\r\n      take: 100,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete old audit logs\r\n   */\r\n  async deleteOlderThan(date: Date) {\r\n    return prisma.auditLog.deleteMany({\r\n      where: {\r\n        createdAt: { lt: date },\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport const auditLogRepository = new AuditLogRepository();\r\n"],"names":[],"mappings":";;;;;;AACA;AACA;;;;;;;AAGO,MAAM;IACX;;GAEC,GACD,MAAM,OAAO,IAAyB,EAAE,EAA6B,EAAE;QACrE,MAAM,KAAK,MAAM,4KAAM;QACvB,OAAO,GAAG,QAAQ,CAAC,MAAM,CAAC;YACxB,MAAM;gBACJ,IAAI,IAAA,mHAAU;gBACd,QAAQ,KAAK,MAAM;gBACnB,QAAQ,KAAK,MAAM;gBACnB,UAAU,KAAK,QAAQ;gBACvB,YAAY,KAAK,UAAU;gBAE3B,SAAS,KAAK,OAAO;gBACrB,WAAW,KAAK,SAAS;gBACzB,WAAW,KAAK,SAAS;YAC3B;QACF;IACF;IAEA;;GAEC,GACD,MAAM,QAAQ,OAAyB,EAAE,OAAO,CAAC,EAAE,QAAQ,EAAE,EAAE;QAC7D,MAAM,QAAmC,CAAC;QAE1C,IAAI,SAAS,QAAQ;YACnB,MAAM,MAAM,GAAG,QAAQ,MAAM;QAC/B;QAEA,IAAI,SAAS,UAAU;YACrB,MAAM,QAAQ,GAAG,QAAQ,QAAQ;QACnC;QAEA,IAAI,SAAS,YAAY;YACvB,MAAM,UAAU,GAAG,QAAQ,UAAU;QACvC;QAEA,IAAI,SAAS,QAAQ;YACnB,MAAM,MAAM,GAAG,QAAQ,MAAM;QAC/B;QAEA,IAAI,SAAS,aAAa,SAAS,SAAS;YAC1C,MAAM,SAAS,GAAG,CAAC;YACnB,IAAI,QAAQ,SAAS,EAAE;gBACrB,MAAM,SAAS,CAAC,GAAG,GAAG,QAAQ,SAAS;YACzC;YACA,IAAI,QAAQ,OAAO,EAAE;gBACnB,MAAM,SAAS,CAAC,GAAG,GAAG,QAAQ,OAAO;YACvC;QACF;QAEA,MAAM,CAAC,MAAM,MAAM,GAAG,MAAM,QAAQ,GAAG,CAAC;YACtC,4KAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC;gBACvB;gBACA,SAAS;oBACP,MAAM;wBACJ,QAAQ;4BACN,IAAI;4BACJ,OAAO;4BACP,WAAW;4BACX,UAAU;wBACZ;oBACF;gBACF;gBACA,MAAM,CAAC,OAAO,CAAC,IAAI;gBACnB,MAAM;gBACN,SAAS;oBAAE,WAAW;gBAAO;YAC/B;YACA,4KAAM,CAAC,QAAQ,CAAC,KAAK,CAAC;gBAAE;YAAM;SAC/B;QAED,OAAO;YACL,MAAM;YACN;YACA;YACA;YACA,YAAY,KAAK,IAAI,CAAC,QAAQ;QAChC;IACF;IAEA;;GAEC,GACD,MAAM,SAAS,KAAa,EAAE;QAC5B,OAAO,4KAAM,CAAC,QAAQ,CAAC,UAAU,CAAC;YAChC,OAAO;gBAAE,IAAI;YAAM;YACnB,SAAS;gBACP,MAAM;oBACJ,QAAQ;wBACN,IAAI;wBACJ,OAAO;wBACP,WAAW;wBACX,UAAU;oBACZ;gBACF;YACF;QACF;IACF;IAEA;;GAEC,GACD,MAAM,WAAW,MAAc,EAAE,OAAyB,EAAE;QAC1D,MAAM,QAAmC;YAAE;QAAO;QAElD,IAAI,SAAS,UAAU;YACrB,MAAM,QAAQ,GAAG,QAAQ,QAAQ;QACnC;QAEA,IAAI,SAAS,QAAQ;YACnB,MAAM,MAAM,GAAG,QAAQ,MAAM;QAC/B;QAEA,OAAO,4KAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC;YAC9B;YACA,SAAS;gBAAE,WAAW;YAAO;YAC7B,MAAM;QACR;IACF;IAEA;;GAEC,GACD,MAAM,eAAe,QAAgB,EAAE,UAAmB,EAAE;QAC1D,MAAM,QAAmC;YAAE;QAAS;QAEpD,IAAI,YAAY;YACd,MAAM,UAAU,GAAG;QACrB;QAEA,OAAO,4KAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC;YAC9B;YACA,SAAS;gBACP,MAAM;oBACJ,QAAQ;wBACN,IAAI;wBACJ,OAAO;wBACP,WAAW;wBACX,UAAU;oBACZ;gBACF;YACF;YACA,SAAS;gBAAE,WAAW;YAAO;YAC7B,MAAM;QACR;IACF;IAEA;;GAEC,GACD,MAAM,gBAAgB,IAAU,EAAE;QAChC,OAAO,4KAAM,CAAC,QAAQ,CAAC,UAAU,CAAC;YAChC,OAAO;gBACL,WAAW;oBAAE,IAAI;gBAAK;YACxB;QACF;IACF;AACF;AAEO,MAAM,qBAAqB,IAAI"}},
    {"offset": {"line": 1836, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/repositories/role.repository.ts"],"sourcesContent":["import { Role, Prisma } from '@prisma/client';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { RoleFilters } from '@/types/role.types';\r\n\r\nexport class RoleRepository {\r\n  /**\r\n   * Find all roles with optional filters\r\n   */\r\n  async findAll(filters?: RoleFilters) {\r\n    const where: Prisma.RoleWhereInput = {};\r\n\r\n    if (filters?.search) {\r\n      where.OR = [\r\n        { name: { contains: filters.search, mode: 'insensitive' } },\r\n        { description: { contains: filters.search, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.isSystem !== undefined) {\r\n      where.isSystem = filters.isSystem;\r\n    }\r\n\r\n    return prisma.role.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find all roles with permissions\r\n   */\r\n  async findAllWithPermissions() {\r\n    const roles = await prisma.role.findMany({\r\n      include: {\r\n        RolePermission: {\r\n          include: {\r\n            Permission: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return roles.map((role: any) => ({\r\n      ...role,\r\n      permissions: role.RolePermission?.map((rp: any) => ({ ...rp, permission: rp.Permission })) || [],\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Find role by ID\r\n   */\r\n  async findById(roleId: string) {\r\n    return prisma.role.findUnique({\r\n      where: { id: roleId },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find role by ID with permissions\r\n   */\r\n  async findByIdWithPermissions(roleId: string) {\r\n    const row = await prisma.role.findUnique({\r\n      where: { id: roleId },\r\n      include: {\r\n        RolePermission: {\r\n          include: {\r\n            Permission: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n    if (!row) return null as any;\r\n    return {\r\n      ...row,\r\n      permissions: (row as any).RolePermission?.map((rp: any) => ({ ...rp, permission: rp.Permission })) || [],\r\n    } as any;\r\n  }\r\n\r\n  /**\r\n   * Find role by name\r\n   */\r\n  async findByName(name: string) {\r\n    return prisma.role.findUnique({\r\n      where: { name },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create new role\r\n   */\r\n  async create(data: Prisma.RoleCreateInput) {\r\n    return prisma.role.create({\r\n      data,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update role\r\n   */\r\n  async update(roleId: string, data: Prisma.RoleUpdateInput) {\r\n    return prisma.role.update({\r\n      where: { id: roleId },\r\n      data,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete role\r\n   */\r\n  async delete(roleId: string) {\r\n    // Check if role is a system role\r\n    const role = await this.findById(roleId);\r\n    if (role?.isSystem) {\r\n      throw new Error('Cannot delete system role');\r\n    }\r\n\r\n    return prisma.role.delete({\r\n      where: { id: roleId },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if role has users\r\n   */\r\n  async hasUsers(roleId: string) {\r\n    const count = await prisma.user.count({\r\n      where: { roleId },\r\n    });\r\n    return count > 0;\r\n  }\r\n\r\n  /**\r\n   * Find users with role\r\n   */\r\n  async findUsersWithRole(roleId: string) {\r\n    return prisma.user.findMany({\r\n      where: { roleId },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get role with user count\r\n   */\r\n  async getRoleWithUserCount(roleId: string) {\r\n    const [role, userCount] = await Promise.all([\r\n      this.findByIdWithPermissions(roleId),\r\n      prisma.user.count({ where: { roleId } }),\r\n    ]);\r\n\r\n    return role ? { ...role, userCount } : null;\r\n  }\r\n}\r\n\r\nexport const roleRepository = new RoleRepository();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2017, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/types/audit.types.ts"],"sourcesContent":["import { AuditLog, User } from '@prisma/client';\r\n\r\n// Base AuditLog type\r\nexport type { AuditLog };\r\n\r\n// AuditLog with relations\r\nexport type AuditLogWithUser = AuditLog & {\r\n  User: {\r\n    id: string;\r\n    email: string;\r\n    firstName: string;\r\n    lastName: string;\r\n  } | null;\r\n};\r\n\r\n// AuditLog input types\r\nexport interface CreateAuditLogInput {\r\n  userId?: string;\r\n  action: string;\r\n  resource: string;\r\n  resourceId?: string;\r\n  details?: Record<string, any>;\r\n  ipAddress?: string;\r\n  userAgent?: string;\r\n}\r\n\r\n// AuditLog filter types\r\nexport interface AuditLogFilters {\r\n  userId?: string;\r\n  resource?: string;\r\n  resourceId?: string;\r\n  action?: string;\r\n  startDate?: Date;\r\n  endDate?: Date;\r\n}\r\n\r\n// AuditLog response types\r\nexport interface AuditLogResponse {\r\n  id: string;\r\n  userId: string | null;\r\n  action: string;\r\n  resource: string;\r\n  resourceId: string | null;\r\n  details: Record<string, any> | null;\r\n  ipAddress: string | null;\r\n  userAgent: string | null;\r\n  createdAt: Date;\r\n  User?: {\r\n    id: string;\r\n    email: string;\r\n    firstName: string;\r\n    lastName: string;\r\n  } | null;\r\n}\r\n\r\n// Paginated audit logs\r\nexport interface PaginatedAuditLogs {\r\n  data: AuditLogWithUser[];\r\n  total: number;\r\n  page: number;\r\n  limit: number;\r\n  totalPages: number;\r\n}\r\n\r\n// Audit actions enum (for type safety)\r\nexport enum AuditAction {\r\n  // User actions\r\n  USER_LOGIN = 'USER_LOGIN',\r\n  USER_LOGOUT = 'USER_LOGOUT',\r\n  USER_LOGIN_FAILED = 'USER_LOGIN_FAILED',\r\n  USER_CREATED = 'USER_CREATED',\r\n  USER_UPDATED = 'USER_UPDATED',\r\n  USER_DELETED = 'USER_DELETED',\r\n  USER_STATUS_CHANGED = 'USER_STATUS_CHANGED',\r\n  USER_PASSWORD_CHANGED = 'USER_PASSWORD_CHANGED',\r\n  USER_PASSWORD_RESET = 'USER_PASSWORD_RESET',\r\n  USER_EMAIL_VERIFIED = 'USER_EMAIL_VERIFIED',\r\n\r\n  // Role actions\r\n  ROLE_CREATED = 'ROLE_CREATED',\r\n  ROLE_UPDATED = 'ROLE_UPDATED',\r\n  ROLE_DELETED = 'ROLE_DELETED',\r\n  PERMISSION_ASSIGNED = 'PERMISSION_ASSIGNED',\r\n  PERMISSION_REMOVED = 'PERMISSION_REMOVED',\r\n\r\n  // Resource access\r\n  UNAUTHORIZED_ACCESS = 'UNAUTHORIZED_ACCESS',\r\n  ACCESS_DENIED = 'ACCESS_DENIED',\r\n}\r\n\r\n// Audit resource enum (for type safety)\r\nexport enum AuditResource {\r\n  USER = 'USER',\r\n  ROLE = 'ROLE',\r\n  PERMISSION = 'PERMISSION',\r\n  SESSION = 'SESSION',\r\n  PRODUCT = 'PRODUCT',\r\n  INVENTORY = 'INVENTORY',\r\n  SALES_ORDER = 'SALES_ORDER',\r\n  PURCHASE_ORDER = 'PURCHASE_ORDER',\r\n  POS_SALE = 'POS_SALE',\r\n  AR = 'ACCOUNTS_RECEIVABLE',\r\n  AP = 'ACCOUNTS_PAYABLE',\r\n  EXPENSE = 'EXPENSE',\r\n  BRANCH = 'BRANCH',\r\n  WAREHOUSE = 'WAREHOUSE',\r\n  SUPPLIER = 'SUPPLIER',\r\n}\r\n"],"names":[],"mappings":";;;;;;AAiEO,IAAA,AAAK,qCAAA;IACV,eAAe;;;;;;;;;;;IAYf,eAAe;;;;;;IAOf,kBAAkB;;;WApBR;;AA0BL,IAAA,AAAK,uCAAA;;;;;;;;;;;;;;;;WAAA"}},
    {"offset": {"line": 2070, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/services/auth.service.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\r\nimport jwt, { SignOptions } from 'jsonwebtoken';\r\nimport { randomUUID } from 'crypto';\r\nimport { userRepository } from '@/repositories/user.repository';\r\nimport { sessionRepository } from '@/repositories/session.repository';\r\nimport { auditLogRepository } from '@/repositories/audit-log.repository';\r\nimport { roleRepository } from '@/repositories/role.repository';\r\nimport {\r\n  LoginInput,\r\n  RegisterInput,\r\n  AuthResponse,\r\n  JWTPayload,\r\n  ResetPasswordInput,\r\n  ForgotPasswordInput,\r\n} from '@/types/auth.types';\r\nimport { CreateUserInput } from '@/types/user.types';\r\nimport { AuditAction, AuditResource } from '@/types/audit.types';\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET;\r\nconst JWT_EXPIRATION = process.env.JWT_EXPIRATION || '24h';\r\n\r\n// Validate JWT_SECRET at module initialization\r\nif (!JWT_SECRET || JWT_SECRET.length < 32) {\r\n  throw new Error(\r\n    'JWT_SECRET must be set in environment variables and be at least 32 characters long. ' +\r\n    'Generate a secure secret with: openssl rand -base64 64'\r\n  );\r\n}\r\n\r\nexport class AuthService {\r\n  /**\r\n   * Register a new user\r\n   */\r\n  async registerUser(data: RegisterInput, ipAddress?: string, userAgent?: string): Promise<AuthResponse> {\r\n    // Check if email already exists\r\n    const existingUser = await userRepository.findByEmail(data.email);\r\n    if (existingUser) {\r\n      return {\r\n        success: false,\r\n        message: 'Email already registered',\r\n      };\r\n    }\r\n\r\n    // Hash password with 14 rounds for stronger security (use lower for tests)\r\n    const rounds = process.env.NODE_ENV === 'test' ? 4 : 14;\r\n    const passwordHash = await bcrypt.hash(data.password, rounds);\r\n\r\n    // Resolve role ID\r\n    let roleId = data.roleId;\r\n    if (!roleId) {\r\n      // Default to Cashier role if not provided\r\n      const defaultRole = await roleRepository.findByName('Cashier');\r\n      if (!defaultRole) {\r\n        throw new Error('Default system role (Cashier) not found. Please contact administrator.');\r\n      }\r\n      roleId = defaultRole.id;\r\n    }\r\n\r\n    // Generate unique ID for user\r\n    const userId = randomUUID();\r\n\r\n    // Create user\r\n    const user = await userRepository.create({\r\n      id: userId,\r\n      email: data.email,\r\n      passwordHash,\r\n      firstName: data.firstName,\r\n      lastName: data.lastName,\r\n      phone: data.phone,\r\n      updatedAt: new Date(),\r\n      Role: { connect: { id: roleId } },\r\n      Branch: data.branchId ? { connect: { id: data.branchId } } : undefined,\r\n      status: 'UNVERIFIED',\r\n      emailVerified: false,\r\n    });\r\n\r\n    // Log the action\r\n    await auditLogRepository.create({\r\n      userId: user.id,\r\n      action: AuditAction.USER_CREATED,\r\n      resource: AuditResource.USER,\r\n      resourceId: user.id,\r\n      ipAddress,\r\n      userAgent,\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      message: 'User registered successfully. Please verify your email.',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Login user\r\n   */\r\n  async login(credentials: LoginInput, ipAddress?: string, userAgent?: string): Promise<AuthResponse> {\r\n    // Find user by email\r\n    const user = await userRepository.findByEmail(credentials.email);\r\n\r\n    if (!user) {\r\n      // Log failed attempt\r\n      await auditLogRepository.create({\r\n        action: AuditAction.USER_LOGIN_FAILED,\r\n        resource: AuditResource.USER,\r\n        details: { email: credentials.email, reason: 'User not found' },\r\n        ipAddress,\r\n        userAgent,\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        message: 'Invalid email or password',\r\n      };\r\n    }\r\n\r\n    // Check if user is active\r\n    if (user.status !== 'ACTIVE') {\r\n      return {\r\n        success: false,\r\n        message: 'Account is inactive, suspended, or pending verification',\r\n      };\r\n    }\r\n\r\n    // Check if email is verified\r\n    if (!user.emailVerified) {\r\n      return {\r\n        success: false,\r\n        message: 'Please verify your email before logging in',\r\n      };\r\n    }\r\n\r\n    // Verify password\r\n    const isPasswordValid = await bcrypt.compare(credentials.password, user.passwordHash);\r\n\r\n    if (!isPasswordValid) {\r\n      // Log failed attempt\r\n      await auditLogRepository.create({\r\n        userId: user.id,\r\n        action: AuditAction.USER_LOGIN_FAILED,\r\n        resource: AuditResource.USER,\r\n        resourceId: user.id,\r\n        details: { reason: 'Invalid password' },\r\n        ipAddress,\r\n        userAgent,\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        message: 'Invalid email or password',\r\n      };\r\n    }\r\n\r\n    // Generate JWT token\r\n    const token = this.generateToken({\r\n      userId: user.id,\r\n      email: user.email,\r\n      roleId: user.roleId,\r\n      branchId: user.branchId || undefined,\r\n    });\r\n\r\n    // Create session\r\n    const expiresAt = new Date();\r\n    expiresAt.setHours(expiresAt.getHours() + 24); // 24 hours from now\r\n\r\n    await sessionRepository.create({\r\n      userId: user.id,\r\n      token,\r\n      ipAddress,\r\n      userAgent,\r\n      expiresAt,\r\n    });\r\n\r\n    // Update last login\r\n    await userRepository.updateLastLogin(user.id);\r\n\r\n    // Log successful login\r\n    await auditLogRepository.create({\r\n      userId: user.id,\r\n      action: AuditAction.USER_LOGIN,\r\n      resource: AuditResource.USER,\r\n      resourceId: user.id,\r\n      ipAddress,\r\n      userAgent,\r\n    });\r\n\r\n    // Get user permissions\r\n    const permissions = (user.Role?.RolePermission || []).map(rp =>\r\n      `${rp.Permission.resource}:${rp.Permission.action}`\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      token,\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        firstName: user.firstName,\r\n        lastName: user.lastName,\r\n        roleId: user.roleId,\r\n        branchId: user.branchId,\r\n        status: user.status,\r\n        emailVerified: user.emailVerified,\r\n        isSuperMegaAdmin: user.isSuperMegaAdmin,\r\n        role: {\r\n          id: user.Role.id,\r\n          name: user.Role.name,\r\n          description: user.Role.description,\r\n        },\r\n        branch: user.Branch ? {\r\n          id: user.Branch.id,\r\n          name: user.Branch.name,\r\n          code: user.Branch.code,\r\n        } : undefined,\r\n      },\r\n      permissions,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Logout user\r\n   */\r\n  async logout(token: string, userId?: string, ipAddress?: string, userAgent?: string): Promise<void> {\r\n    // Delete session\r\n    await sessionRepository.deleteByToken(token);\r\n\r\n    // Log logout\r\n    if (userId) {\r\n      await auditLogRepository.create({\r\n        userId,\r\n        action: AuditAction.USER_LOGOUT,\r\n        resource: AuditResource.USER,\r\n        resourceId: userId,\r\n        ipAddress,\r\n        userAgent,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate session and get user\r\n   */\r\n  async validateSession(token: string) {\r\n    const session = await sessionRepository.findByToken(token);\r\n\r\n    if (!session) {\r\n      return null;\r\n    }\r\n\r\n    // Check if session is expired\r\n    if (session.expiresAt < new Date()) {\r\n      await sessionRepository.deleteByToken(token);\r\n      return null;\r\n    }\r\n\r\n    // Check if user is still active\r\n    if (session.User.status !== 'ACTIVE') {\r\n      return null;\r\n    }\r\n\r\n    return session;\r\n  }\r\n\r\n  /**\r\n   * Change password (authenticated user)\r\n   */\r\n  async changePassword(\r\n    userId: string,\r\n    oldPassword: string,\r\n    newPassword: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<{ success: boolean; message: string }> {\r\n    const user = await userRepository.findByEmail((await userRepository.findById(userId))!.email);\r\n\r\n    if (!user) {\r\n      return { success: false, message: 'User not found' };\r\n    }\r\n\r\n    // Verify old password\r\n    const isPasswordValid = await bcrypt.compare(oldPassword, user.passwordHash);\r\n    if (!isPasswordValid) {\r\n      return { success: false, message: 'Current password is incorrect' };\r\n    }\r\n\r\n    // Hash new password with 14 rounds\r\n    const newPasswordHash = await bcrypt.hash(newPassword, 14);\r\n\r\n    // Update password\r\n    await userRepository.updatePassword(userId, newPasswordHash);\r\n\r\n    // Invalidate all sessions\r\n    await sessionRepository.deleteByUser(userId);\r\n\r\n    // Log password change\r\n    await auditLogRepository.create({\r\n      userId,\r\n      action: AuditAction.USER_PASSWORD_CHANGED,\r\n      resource: AuditResource.USER,\r\n      resourceId: userId,\r\n      ipAddress,\r\n      userAgent,\r\n    });\r\n\r\n    return { success: true, message: 'Password changed successfully' };\r\n  }\r\n\r\n  /**\r\n   * Verify email\r\n   */\r\n  async verifyEmail(userId: string): Promise<{ success: boolean; message: string }> {\r\n    await userRepository.updateEmailVerified(userId, true);\r\n\r\n    await auditLogRepository.create({\r\n      userId,\r\n      action: AuditAction.USER_EMAIL_VERIFIED,\r\n      resource: AuditResource.USER,\r\n      resourceId: userId,\r\n    });\r\n\r\n    return { success: true, message: 'Email verified successfully' };\r\n  }\r\n\r\n  /**\r\n   * Generate JWT token\r\n   */\r\n  private generateToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {\r\n\r\n    return jwt.sign(payload, JWT_SECRET as string, { expiresIn: '24h' });\r\n  }\r\n\r\n  /**\r\n   * Verify JWT token\r\n   */\r\n  verifyToken(token: string): JWTPayload | null {\r\n    try {\r\n      const decoded = jwt.verify(token, JWT_SECRET as string);\r\n      return decoded as JWTPayload;\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport const authService = new AuthService();\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;;;;;;;;;;;;;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU;AACzC,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI;AAErD,+CAA+C;AAC/C,IAAI,CAAC,cAAc,WAAW,MAAM,GAAG,IAAI;IACzC,MAAM,IAAI,MACR,yFACA;AAEJ;AAEO,MAAM;IACX;;GAEC,GACD,MAAM,aAAa,IAAmB,EAAE,SAAkB,EAAE,SAAkB,EAAyB;QACrG,gCAAgC;QAChC,MAAM,eAAe,MAAM,yLAAc,CAAC,WAAW,CAAC,KAAK,KAAK;QAChE,IAAI,cAAc;YAChB,OAAO;gBACL,SAAS;gBACT,SAAS;YACX;QACF;QAEA,2EAA2E;QAC3E,MAAM,SAAS,sCAAkC,0BAAI;QACrD,MAAM,eAAe,MAAM,iLAAM,CAAC,IAAI,CAAC,KAAK,QAAQ,EAAE;QAEtD,kBAAkB;QAClB,IAAI,SAAS,KAAK,MAAM;QACxB,IAAI,CAAC,QAAQ;YACX,0CAA0C;YAC1C,MAAM,cAAc,MAAM,yLAAc,CAAC,UAAU,CAAC;YACpD,IAAI,CAAC,aAAa;gBAChB,MAAM,IAAI,MAAM;YAClB;YACA,SAAS,YAAY,EAAE;QACzB;QAEA,8BAA8B;QAC9B,MAAM,SAAS,IAAA,mHAAU;QAEzB,cAAc;QACd,MAAM,OAAO,MAAM,yLAAc,CAAC,MAAM,CAAC;YACvC,IAAI;YACJ,OAAO,KAAK,KAAK;YACjB;YACA,WAAW,KAAK,SAAS;YACzB,UAAU,KAAK,QAAQ;YACvB,OAAO,KAAK,KAAK;YACjB,WAAW,IAAI;YACf,MAAM;gBAAE,SAAS;oBAAE,IAAI;gBAAO;YAAE;YAChC,QAAQ,KAAK,QAAQ,GAAG;gBAAE,SAAS;oBAAE,IAAI,KAAK,QAAQ;gBAAC;YAAE,IAAI;YAC7D,QAAQ;YACR,eAAe;QACjB;QAEA,iBAAiB;QACjB,MAAM,qMAAkB,CAAC,MAAM,CAAC;YAC9B,QAAQ,KAAK,EAAE;YACf,QAAQ,2KAAW,CAAC,YAAY;YAChC,UAAU,6KAAa,CAAC,IAAI;YAC5B,YAAY,KAAK,EAAE;YACnB;YACA;QACF;QAEA,OAAO;YACL,SAAS;YACT,SAAS;QACX;IACF;IAEA;;GAEC,GACD,MAAM,MAAM,WAAuB,EAAE,SAAkB,EAAE,SAAkB,EAAyB;QAClG,qBAAqB;QACrB,MAAM,OAAO,MAAM,yLAAc,CAAC,WAAW,CAAC,YAAY,KAAK;QAE/D,IAAI,CAAC,MAAM;YACT,qBAAqB;YACrB,MAAM,qMAAkB,CAAC,MAAM,CAAC;gBAC9B,QAAQ,2KAAW,CAAC,iBAAiB;gBACrC,UAAU,6KAAa,CAAC,IAAI;gBAC5B,SAAS;oBAAE,OAAO,YAAY,KAAK;oBAAE,QAAQ;gBAAiB;gBAC9D;gBACA;YACF;YAEA,OAAO;gBACL,SAAS;gBACT,SAAS;YACX;QACF;QAEA,0BAA0B;QAC1B,IAAI,KAAK,MAAM,KAAK,UAAU;YAC5B,OAAO;gBACL,SAAS;gBACT,SAAS;YACX;QACF;QAEA,6BAA6B;QAC7B,IAAI,CAAC,KAAK,aAAa,EAAE;YACvB,OAAO;gBACL,SAAS;gBACT,SAAS;YACX;QACF;QAEA,kBAAkB;QAClB,MAAM,kBAAkB,MAAM,iLAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,YAAY;QAEpF,IAAI,CAAC,iBAAiB;YACpB,qBAAqB;YACrB,MAAM,qMAAkB,CAAC,MAAM,CAAC;gBAC9B,QAAQ,KAAK,EAAE;gBACf,QAAQ,2KAAW,CAAC,iBAAiB;gBACrC,UAAU,6KAAa,CAAC,IAAI;gBAC5B,YAAY,KAAK,EAAE;gBACnB,SAAS;oBAAE,QAAQ;gBAAmB;gBACtC;gBACA;YACF;YAEA,OAAO;gBACL,SAAS;gBACT,SAAS;YACX;QACF;QAEA,qBAAqB;QACrB,MAAM,QAAQ,IAAI,CAAC,aAAa,CAAC;YAC/B,QAAQ,KAAK,EAAE;YACf,OAAO,KAAK,KAAK;YACjB,QAAQ,KAAK,MAAM;YACnB,UAAU,KAAK,QAAQ,IAAI;QAC7B;QAEA,iBAAiB;QACjB,MAAM,YAAY,IAAI;QACtB,UAAU,QAAQ,CAAC,UAAU,QAAQ,KAAK,KAAK,oBAAoB;QAEnE,MAAM,+LAAiB,CAAC,MAAM,CAAC;YAC7B,QAAQ,KAAK,EAAE;YACf;YACA;YACA;YACA;QACF;QAEA,oBAAoB;QACpB,MAAM,yLAAc,CAAC,eAAe,CAAC,KAAK,EAAE;QAE5C,uBAAuB;QACvB,MAAM,qMAAkB,CAAC,MAAM,CAAC;YAC9B,QAAQ,KAAK,EAAE;YACf,QAAQ,2KAAW,CAAC,UAAU;YAC9B,UAAU,6KAAa,CAAC,IAAI;YAC5B,YAAY,KAAK,EAAE;YACnB;YACA;QACF;QAEA,uBAAuB;QACvB,MAAM,cAAc,CAAC,KAAK,IAAI,EAAE,kBAAkB,EAAE,EAAE,GAAG,CAAC,CAAA,KACxD,GAAG,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,UAAU,CAAC,MAAM,EAAE;QAGrD,OAAO;YACL,SAAS;YACT;YACA,MAAM;gBACJ,IAAI,KAAK,EAAE;gBACX,OAAO,KAAK,KAAK;gBACjB,WAAW,KAAK,SAAS;gBACzB,UAAU,KAAK,QAAQ;gBACvB,QAAQ,KAAK,MAAM;gBACnB,UAAU,KAAK,QAAQ;gBACvB,QAAQ,KAAK,MAAM;gBACnB,eAAe,KAAK,aAAa;gBACjC,kBAAkB,KAAK,gBAAgB;gBACvC,MAAM;oBACJ,IAAI,KAAK,IAAI,CAAC,EAAE;oBAChB,MAAM,KAAK,IAAI,CAAC,IAAI;oBACpB,aAAa,KAAK,IAAI,CAAC,WAAW;gBACpC;gBACA,QAAQ,KAAK,MAAM,GAAG;oBACpB,IAAI,KAAK,MAAM,CAAC,EAAE;oBAClB,MAAM,KAAK,MAAM,CAAC,IAAI;oBACtB,MAAM,KAAK,MAAM,CAAC,IAAI;gBACxB,IAAI;YACN;YACA;QACF;IACF;IAEA;;GAEC,GACD,MAAM,OAAO,KAAa,EAAE,MAAe,EAAE,SAAkB,EAAE,SAAkB,EAAiB;QAClG,iBAAiB;QACjB,MAAM,+LAAiB,CAAC,aAAa,CAAC;QAEtC,aAAa;QACb,IAAI,QAAQ;YACV,MAAM,qMAAkB,CAAC,MAAM,CAAC;gBAC9B;gBACA,QAAQ,2KAAW,CAAC,WAAW;gBAC/B,UAAU,6KAAa,CAAC,IAAI;gBAC5B,YAAY;gBACZ;gBACA;YACF;QACF;IACF;IAEA;;GAEC,GACD,MAAM,gBAAgB,KAAa,EAAE;QACnC,MAAM,UAAU,MAAM,+LAAiB,CAAC,WAAW,CAAC;QAEpD,IAAI,CAAC,SAAS;YACZ,OAAO;QACT;QAEA,8BAA8B;QAC9B,IAAI,QAAQ,SAAS,GAAG,IAAI,QAAQ;YAClC,MAAM,+LAAiB,CAAC,aAAa,CAAC;YACtC,OAAO;QACT;QAEA,gCAAgC;QAChC,IAAI,QAAQ,IAAI,CAAC,MAAM,KAAK,UAAU;YACpC,OAAO;QACT;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,eACJ,MAAc,EACd,WAAmB,EACnB,WAAmB,EACnB,SAAkB,EAClB,SAAkB,EAC8B;QAChD,MAAM,OAAO,MAAM,yLAAc,CAAC,WAAW,CAAC,CAAC,MAAM,yLAAc,CAAC,QAAQ,CAAC,OAAO,EAAG,KAAK;QAE5F,IAAI,CAAC,MAAM;YACT,OAAO;gBAAE,SAAS;gBAAO,SAAS;YAAiB;QACrD;QAEA,sBAAsB;QACtB,MAAM,kBAAkB,MAAM,iLAAM,CAAC,OAAO,CAAC,aAAa,KAAK,YAAY;QAC3E,IAAI,CAAC,iBAAiB;YACpB,OAAO;gBAAE,SAAS;gBAAO,SAAS;YAAgC;QACpE;QAEA,mCAAmC;QACnC,MAAM,kBAAkB,MAAM,iLAAM,CAAC,IAAI,CAAC,aAAa;QAEvD,kBAAkB;QAClB,MAAM,yLAAc,CAAC,cAAc,CAAC,QAAQ;QAE5C,0BAA0B;QAC1B,MAAM,+LAAiB,CAAC,YAAY,CAAC;QAErC,sBAAsB;QACtB,MAAM,qMAAkB,CAAC,MAAM,CAAC;YAC9B;YACA,QAAQ,2KAAW,CAAC,qBAAqB;YACzC,UAAU,6KAAa,CAAC,IAAI;YAC5B,YAAY;YACZ;YACA;QACF;QAEA,OAAO;YAAE,SAAS;YAAM,SAAS;QAAgC;IACnE;IAEA;;GAEC,GACD,MAAM,YAAY,MAAc,EAAkD;QAChF,MAAM,yLAAc,CAAC,mBAAmB,CAAC,QAAQ;QAEjD,MAAM,qMAAkB,CAAC,MAAM,CAAC;YAC9B;YACA,QAAQ,2KAAW,CAAC,mBAAmB;YACvC,UAAU,6KAAa,CAAC,IAAI;YAC5B,YAAY;QACd;QAEA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA8B;IACjE;IAEA;;GAEC,GACD,AAAQ,cAAc,OAAwC,EAAU;QAEtE,OAAO,qLAAG,CAAC,IAAI,CAAC,SAAS,YAAsB;YAAE,WAAW;QAAM;IACpE;IAEA;;GAEC,GACD,YAAY,KAAa,EAAqB;QAC5C,IAAI;YACF,MAAM,UAAU,qLAAG,CAAC,MAAM,CAAC,OAAO;YAClC,OAAO;QACT,EAAE,OAAO,OAAO;YACd,OAAO;QACT;IACF;AACF;AAEO,MAAM,cAAc,IAAI"}},
    {"offset": {"line": 2395, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/services/user.service.ts"],"sourcesContent":["// @ts-nocheck\r\nimport bcrypt from 'bcryptjs';\r\nimport { Prisma } from '@prisma/client';\r\nimport { userRepository } from '@/repositories/user.repository';\r\nimport { auditLogRepository } from '@/repositories/audit-log.repository';\r\nimport { CreateUserInput, UpdateUserInput, UserFilters, UserStatus } from '@/types/user.types';\r\nimport { AuditAction, AuditResource } from '@/types/audit.types';\r\nimport { NotFoundError, ConflictError } from '@/lib/errors';\r\n\r\nexport class UserService {\r\n  /**\r\n   * Get all users with filtering and pagination\r\n   */\r\n  async getAllUsers(filters?: UserFilters, page = 1, limit = 20) {\r\n    return await userRepository.findAll(filters, page, limit);\r\n  }\r\n\r\n  /**\r\n   * Get user by ID\r\n   */\r\n  async getUserById(id: string) {\r\n    return await userRepository.findById(id);\r\n  }\r\n\r\n  /**\r\n   * Get user by email\r\n   */\r\n  async getUserByEmail(email: string) {\r\n    return await userRepository.findByEmail(email);\r\n  }\r\n\r\n  /**\r\n   * Create new user\r\n   */\r\n  async createUser(\r\n    data: CreateUserInput,\r\n    createdById: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    // Check if email already exists\r\n    const existingUser = await userRepository.findByEmail(data.email);\r\n    if (existingUser) {\r\n      throw new ConflictError('Email already exists', { email: data.email });\r\n    }\r\n\r\n    // Hash password\r\n    const passwordHash = await bcrypt.hash(data.password, 12);\r\n\r\n    // Create user data for Prisma\r\n    // @ts-expect-error - TypeScript incorrectly inferring type\r\n    const createData: Prisma.UserCreateInput = {\r\n      email: data.email,\r\n      passwordHash,\r\n      firstName: data.firstName,\r\n      lastName: data.lastName,\r\n      phone: data.phone,\r\n      Role: { connect: { id: data.roleId } },\r\n      Branch: data.branchId ? { connect: { id: data.branchId } } : undefined,\r\n      status: 'ACTIVE',\r\n      emailVerified: false,\r\n    };\r\n\r\n    // Create user\r\n    const user = await userRepository.create(createData);\r\n\r\n    // Log the action\r\n    await auditLogRepository.create({\r\n      userId: createdById,\r\n      action: AuditAction.USER_CREATED,\r\n      resource: AuditResource.USER,\r\n      resourceId: user.id,\r\n      details: {\r\n        email: user.email,\r\n        firstName: user.firstName,\r\n        lastName: user.lastName,\r\n      },\r\n      ipAddress,\r\n      userAgent,\r\n    });\r\n\r\n    return user;\r\n  }\r\n\r\n  /**\r\n   * Update user\r\n   */\r\n  async updateUser(\r\n    id: string,\r\n    data: UpdateUserInput,\r\n    updatedById: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const existingUser = await userRepository.findById(id);\r\n    if (!existingUser) {\r\n      throw new NotFoundError('User', id);\r\n    }\r\n\r\n    // Check if email is being changed and if it's already taken\r\n    if (data.email && data.email !== existingUser.email) {\r\n      const emailExists = await userRepository.findByEmail(data.email);\r\n      if (emailExists) {\r\n        throw new ConflictError('Email already exists', { email: data.email });\r\n      }\r\n    }\r\n\r\n    // Prepare update data for Prisma\r\n    const updateData: Prisma.UserUpdateInput = {\r\n      ...(data.email && { email: data.email }),\r\n      ...(data.firstName && { firstName: data.firstName }),\r\n      ...(data.lastName && { lastName: data.lastName }),\r\n      ...(data.phone !== undefined && { phone: data.phone }),\r\n      ...(data.status && { status: data.status }),\r\n      ...(data.emailVerified !== undefined && { emailVerified: data.emailVerified }),\r\n    };\r\n\r\n    if (data.roleId) {\r\n      updateData.Role = { connect: { id: data.roleId } };\r\n    }\r\n\r\n    if (data.branchId !== undefined) {\r\n      updateData.Branch = data.branchId ? { connect: { id: data.branchId } } : { disconnect: true };\r\n    }\r\n\r\n    // Update user\r\n    const updatedUser = await userRepository.update(id, updateData);\r\n\r\n    // Log the action\r\n    await auditLogRepository.create({\r\n      userId: updatedById,\r\n      action: AuditAction.USER_UPDATED,\r\n      resource: AuditResource.USER,\r\n      resourceId: id,\r\n      details: {\r\n        changes: data,\r\n      },\r\n      ipAddress,\r\n      userAgent,\r\n    });\r\n\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Delete user (soft delete by setting status to INACTIVE)\r\n   */\r\n  async deleteUser(\r\n    id: string,\r\n    deletedById: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const user = await userRepository.findById(id);\r\n    if (!user) {\r\n      throw new NotFoundError('User', id);\r\n    }\r\n\r\n    // Soft delete by setting status to INACTIVE\r\n    await userRepository.update(id, { status: 'INACTIVE' });\r\n\r\n    // Log the action\r\n    await auditLogRepository.create({\r\n      userId: deletedById,\r\n      action: AuditAction.USER_DELETED,\r\n      resource: AuditResource.USER,\r\n      resourceId: id,\r\n      details: {\r\n        email: user.email,\r\n        firstName: user.firstName,\r\n        lastName: user.lastName,\r\n      },\r\n      ipAddress,\r\n      userAgent,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Activate user\r\n   */\r\n  async activateUser(\r\n    id: string,\r\n    activatedById: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const user = await userRepository.findById(id);\r\n    if (!user) {\r\n      throw new Error('User not found');\r\n    }\r\n\r\n    await userRepository.update(id, { status: 'ACTIVE' });\r\n\r\n    await auditLogRepository.create({\r\n      userId: activatedById,\r\n      action: AuditAction.USER_UPDATED,\r\n      resource: AuditResource.USER,\r\n      resourceId: id,\r\n      details: { status: 'ACTIVE' },\r\n      ipAddress,\r\n      userAgent,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Suspend user\r\n   */\r\n  async suspendUser(\r\n    id: string,\r\n    suspendedById: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const user = await userRepository.findById(id);\r\n    if (!user) {\r\n      throw new Error('User not found');\r\n    }\r\n\r\n    await userRepository.update(id, { status: 'SUSPENDED' });\r\n\r\n    await auditLogRepository.create({\r\n      userId: suspendedById,\r\n      action: AuditAction.USER_UPDATED,\r\n      resource: AuditResource.USER,\r\n      resourceId: id,\r\n      details: { status: 'SUSPENDED' },\r\n      ipAddress,\r\n      userAgent,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get users by role\r\n   */\r\n  async getUsersByRole(roleId: string, page = 1, limit = 20) {\r\n    return await userRepository.findAll({ roleId }, page, limit);\r\n  }\r\n\r\n  /**\r\n   * Get users by branch\r\n   */\r\n  async getUsersByBranch(branchId: string, page = 1, limit = 20) {\r\n    return await userRepository.findAll({ branchId }, page, limit);\r\n  }\r\n\r\n  /**\r\n   * Get users by status\r\n   */\r\n  async getUsersByStatus(status: UserStatus, page = 1, limit = 20) {\r\n    return await userRepository.findAll({ status }, page, limit);\r\n  }\r\n\r\n  /**\r\n   * Search users\r\n   */\r\n  async searchUsers(searchTerm: string, page = 1, limit = 20) {\r\n    return await userRepository.findAll({ search: searchTerm }, page, limit);\r\n  }\r\n}\r\n\r\nexport const userService = new UserService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2660, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HI/Documents/GitHub/buenasv2/app/api/data-maintenance/%5Btype%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { dataMaintenanceService } from '@/services/data-maintenance.service';\r\nimport { ReferenceDataType } from '@/types/data-maintenance.types';\r\nimport { authService } from '@/services/auth.service';\r\nimport { userService } from '@/services/user.service';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\nconst VALID_TYPES: ReferenceDataType[] = [\r\n  'product-categories',\r\n  'expense-categories',\r\n  'payment-methods',\r\n  'units-of-measure',\r\n  'expense-vendors',\r\n  'sales-agents',\r\n];\r\n\r\nexport async function GET(request: NextRequest, { params }: { params: Promise<{ type: string }> }) {\r\n  try {\r\n    // 1. Verify Authentication\r\n    const token = request.cookies.get('auth-token')?.value || request.headers.get('authorization')?.replace('Bearer ', '');\r\n\r\n    if (!token) {\r\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n\r\n    const payload = authService.verifyToken(token);\r\n    if (!payload) {\r\n      return NextResponse.json({ success: false, error: 'Invalid token' }, { status: 401 });\r\n    }\r\n\r\n    // 2. Verify Authentication\r\n    const user = await userService.getUserById(payload.userId);\r\n    if (!user) {\r\n      return NextResponse.json({ success: false, error: 'User not found' }, { status: 404 });\r\n    }\r\n\r\n    const { type } = await params;\r\n\r\n    // Validate type\r\n    if (!VALID_TYPES.includes(type as ReferenceDataType)) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Invalid reference data type' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const { searchParams } = new URL(request.url);\r\n    const status = searchParams.get('status') || undefined;\r\n    const search = searchParams.get('search') || undefined;\r\n\r\n    const data = await dataMaintenanceService.getAll(type as ReferenceDataType, {\r\n      status,\r\n      search,\r\n    });\r\n\r\n    const response = NextResponse.json({\r\n      success: true,\r\n      data,\r\n    });\r\n\r\n    // Add Cache-Control headers for master data (5 minutes cache)\r\n    // Add Cache-Control headers for master data (0 seconds cache to ensure immediate updates)\r\n    response.headers.set('Cache-Control', 'public, max-age=0, must-revalidate');\r\n\r\n    return response;\r\n  } catch (error: any) {\r\n    console.error('Error fetching reference data:', error);\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: error.message || 'Failed to fetch data',\r\n      },\r\n      { status: error.statusCode || 500 }\r\n    );\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest, { params }: { params: Promise<{ type: string }> }) {\r\n  try {\r\n    // 1. Verify Authentication\r\n    const token = request.cookies.get('auth-token')?.value || request.headers.get('authorization')?.replace('Bearer ', '');\r\n\r\n    if (!token) {\r\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n\r\n    const payload = authService.verifyToken(token);\r\n    if (!payload) {\r\n      return NextResponse.json({ success: false, error: 'Invalid token' }, { status: 401 });\r\n    }\r\n\r\n    // 2. Verify Authentication\r\n    const user = await userService.getUserById(payload.userId);\r\n    if (!user) {\r\n      return NextResponse.json({ success: false, error: 'User not found' }, { status: 404 });\r\n    }\r\n\r\n    const { type } = await params;\r\n\r\n    // Validate type\r\n    if (!VALID_TYPES.includes(type as ReferenceDataType)) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Invalid reference data type' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const body = await request.json();\r\n    const data = await dataMaintenanceService.create(type as ReferenceDataType, body);\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('Error creating reference data:', error);\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: error.message || 'Failed to create data',\r\n        errors: error.fields || error.errors || undefined,\r\n      },\r\n      { status: error.statusCode || 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}